{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { APP_BOOTSTRAP_LISTENER, PLATFORM_ID, NgModule, Injectable, InjectionToken, Inject, inject, NgZone, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { DOCUMENT, isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { Subject, BehaviorSubject, Observable, merge, asapScheduler, of, fromEvent } from 'rxjs';\nimport { filter, debounceTime, map, switchMap, takeUntil, take, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/browser-provider.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Find all of the server-generated stylings, if any, and remove them\n * This will be in the form of inline classes and the style block in the\n * head of the DOM\n * @param {?} _document\n * @param {?} platformId\n * @return {?}\n */\nfunction removeStyles(_document, platformId) {\n  return (\n    /**\n    * @return {?}\n    */\n    () => {\n      if (isPlatformBrowser(platformId)) {\n        /** @type {?} */\n        const elements = Array.from(_document.querySelectorAll(`[class*=${CLASS_NAME}]`));\n        // RegExp constructor should only be used if passing a variable to the constructor.\n        // When using static regular expression it is more performant to use reg exp literal.\n        // This is also needed to provide Safari 9 compatibility, please see\n        // https://stackoverflow.com/questions/37919802 for more discussion.\n        /** @type {?} */\n        const classRegex = /\\bflex-layout-.+?\\b/g;\n        elements.forEach(\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        el => {\n          el.classList.contains(`${CLASS_NAME}ssr`) && el.parentNode ? el.parentNode.removeChild(el) : el.className.replace(classRegex, '');\n        });\n      }\n    }\n  );\n}\n/**\n *  Provider to remove SSR styles on the browser\n * @type {?}\n */\nconst BROWSER_PROVIDER = {\n  provide: /** @type {?} */APP_BOOTSTRAP_LISTENER,\n  useFactory: removeStyles,\n  deps: [DOCUMENT, PLATFORM_ID],\n  multi: true\n};\n/** @type {?} */\nconst CLASS_NAME = 'flex-layout-';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * *****************************************************************\n * Define module for common Angular Layout utilities\n * *****************************************************************\n */\nclass CoreModule {}\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-change.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Class instances emitted [to observers] for each mql notification\n */\nclass MediaChange {\n  /**\n   * @param {?=} matches whether the mediaQuery is currently activated\n   * @param {?=} mediaQuery e.g. (min-width: 600px) and (max-width: 959px)\n   * @param {?=} mqAlias e.g. gt-sm, md, gt-lg\n   * @param {?=} suffix e.g. GtSM, Md, GtLg\n   * @param {?=} priority the priority of activation for the given breakpoint\n   */\n  constructor(matches = false, mediaQuery = 'all', mqAlias = '', suffix = '', priority = 0) {\n    this.matches = matches;\n    this.mediaQuery = mediaQuery;\n    this.mqAlias = mqAlias;\n    this.suffix = suffix;\n    this.priority = priority;\n    this.property = '';\n  }\n  /**\n   * Create an exact copy of the MediaChange\n   * @return {?}\n   */\n  clone() {\n    return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/stylesheet-map/stylesheet-map.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Utility to emulate a CSS stylesheet\n *\n * This utility class stores all of the styles for a given HTML element\n * as a readonly `stylesheet` map.\n */\nlet StylesheetMap = /*#__PURE__*/(() => {\n  class StylesheetMap {\n    constructor() {\n      this.stylesheet = new Map();\n    }\n    /**\n     * Add an individual style to an HTML element\n     * @param {?} element\n     * @param {?} style\n     * @param {?} value\n     * @return {?}\n     */\n    addStyleToElement(element, style, value) {\n      /** @type {?} */\n      const stylesheet = this.stylesheet.get(element);\n      if (stylesheet) {\n        stylesheet.set(style, value);\n      } else {\n        this.stylesheet.set(element, new Map([[style, value]]));\n      }\n    }\n    /**\n     * Clear the virtual stylesheet\n     * @return {?}\n     */\n    clearStyles() {\n      this.stylesheet.clear();\n    }\n    /**\n     * Retrieve a given style for an HTML element\n     * @param {?} el\n     * @param {?} styleName\n     * @return {?}\n     */\n    getStyleForElement(el, styleName) {\n      /** @type {?} */\n      const styles = this.stylesheet.get(el);\n      /** @type {?} */\n      let value = '';\n      if (styles) {\n        /** @type {?} */\n        const style = styles.get(styleName);\n        if (typeof style === 'number' || typeof style === 'string') {\n          value = style + '';\n        }\n      }\n      return value;\n    }\n  }\n  /** @nocollapse */StylesheetMap.ɵprov = ɵɵdefineInjectable({\n    factory: function StylesheetMap_Factory() {\n      return new StylesheetMap();\n    },\n    token: StylesheetMap,\n    providedIn: \"root\"\n  });\n  return StylesheetMap;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/stylesheet-map/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/library-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst DEFAULT_CONFIG = {\n  addFlexToParent: true,\n  addOrientationBps: false,\n  disableDefaultBps: false,\n  disableVendorPrefixes: false,\n  serverLoaded: false,\n  useColumnBasisZero: true,\n  printWithBreakpoints: [],\n  mediaTriggerAutoRestore: true,\n  ssrObserveBreakpoints: []\n};\n/** @type {?} */\nconst LAYOUT_CONFIG = /*#__PURE__*/new InjectionToken('Flex Layout token, config options for the library', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => DEFAULT_CONFIG\n});\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/server-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Token that is provided to tell whether the FlexLayoutServerModule\n * has been included in the bundle\n *\n * NOTE: This can be manually provided to disable styles when using SSR\n * @type {?}\n */\nconst SERVER_TOKEN = /*#__PURE__*/new InjectionToken('FlexLayoutServerLoaded', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => false\n});\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/breakpoint-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst BREAKPOINT = /*#__PURE__*/new InjectionToken('Flex Layout token, collect all breakpoints into one provider', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => null\n});\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/add-alias.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * For the specified MediaChange, make sure it contains the breakpoint alias\n * and suffix (if available).\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction mergeAlias(dest, source) {\n  dest = dest ? dest.clone() : new MediaChange();\n  if (source) {\n    dest.mqAlias = source.alias;\n    dest.mediaQuery = source.mediaQuery;\n    dest.suffix = /** @type {?} */source.suffix;\n    dest.priority = /** @type {?} */source.priority;\n  }\n  return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/layout-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @type {?}\n */\nconst INLINE = 'inline';\n/** @type {?} */\nconst LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\nfunction buildLayoutCSS(value) {\n  let [direction, wrap, isInline] = validateValue(value);\n  return buildCSS(direction, wrap, isInline);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\nfunction validateValue(value) {\n  value = value ? value.toLowerCase() : '';\n  let [direction, wrap, inline] = value.split(' ');\n  // First value must be the `flex-direction`\n  if (!LAYOUT_VALUES.find(\n  /**\n  * @param {?} x\n  * @return {?}\n  */\n  x => x === direction)) {\n    direction = LAYOUT_VALUES[0];\n  }\n  if (wrap === INLINE) {\n    wrap = inline !== INLINE ? inline : '';\n    inline = INLINE;\n  }\n  return [direction, validateWrapValue(wrap), !!inline];\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\nfunction validateWrapValue(value) {\n  if (!!value) {\n    switch (value.toLowerCase()) {\n      case 'reverse':\n      case 'wrap-reverse':\n      case 'reverse-wrap':\n        value = 'wrap-reverse';\n        break;\n      case 'no':\n      case 'none':\n      case 'nowrap':\n        value = 'nowrap';\n        break;\n      // All other values fallback to 'wrap'\n      default:\n        value = 'wrap';\n        break;\n    }\n  }\n  return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @param {?=} inline\n * @return {?}\n */\nfunction buildCSS(direction, wrap = null, inline = false) {\n  return {\n    'display': inline ? 'inline-flex' : 'flex',\n    'box-sizing': 'border-box',\n    'flex-direction': direction,\n    'flex-wrap': !!wrap ? wrap : null\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/base/base2.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass BaseDirective2 {\n  /**\n   * @protected\n   * @param {?} elementRef\n   * @param {?} styleBuilder\n   * @param {?} styler\n   * @param {?} marshal\n   */\n  constructor(elementRef, styleBuilder, styler, marshal) {\n    this.elementRef = elementRef;\n    this.styleBuilder = styleBuilder;\n    this.styler = styler;\n    this.marshal = marshal;\n    this.DIRECTIVE_KEY = '';\n    this.inputs = [];\n    /**\n     * The most recently used styles for the builder\n     */\n    this.mru = {};\n    this.destroySubject = new Subject();\n    /**\n     * Cache map for style computation\n     */\n    this.styleCache = new Map();\n  }\n  /**\n   * Access to host element's parent DOM node\n   * @protected\n   * @return {?}\n   */\n  get parentElement() {\n    return this.elementRef.nativeElement.parentElement;\n  }\n  /**\n   * Access to the HTMLElement for the directive\n   * @protected\n   * @return {?}\n   */\n  get nativeElement() {\n    return this.elementRef.nativeElement;\n  }\n  /**\n   * Access to the activated value for the directive\n   * @return {?}\n   */\n  get activatedValue() {\n    return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set activatedValue(value) {\n    this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, value, this.marshal.activatedAlias);\n  }\n  /**\n   * For \\@Input changes\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    Object.keys(changes).forEach(\n    /**\n    * @param {?} key\n    * @return {?}\n    */\n    key => {\n      if (this.inputs.indexOf(key) !== -1) {\n        /** @type {?} */\n        const bp = key.split('.').slice(1).join('.');\n        /** @type {?} */\n        const val = changes[key].currentValue;\n        this.setValue(val, bp);\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.destroySubject.next();\n    this.destroySubject.complete();\n    this.marshal.releaseElement(this.nativeElement);\n  }\n  /**\n   * Register with central marshaller service\n   * @protected\n   * @param {?=} extraTriggers\n   * @return {?}\n   */\n  init(extraTriggers = []) {\n    this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), extraTriggers);\n  }\n  /**\n   * Add styles to the element using predefined style builder\n   * @protected\n   * @param {?} input\n   * @param {?=} parent\n   * @return {?}\n   */\n  addStyles(input, parent) {\n    /** @type {?} */\n    const builder = this.styleBuilder;\n    /** @type {?} */\n    const useCache = builder.shouldCache;\n    /** @type {?} */\n    let genStyles = this.styleCache.get(input);\n    if (!genStyles || !useCache) {\n      genStyles = builder.buildStyles(input, parent);\n      if (useCache) {\n        this.styleCache.set(input, genStyles);\n      }\n    }\n    this.mru = Object.assign({}, genStyles);\n    this.applyStyleToElement(genStyles);\n    builder.sideEffect(input, genStyles, parent);\n  }\n  /**\n   * Remove generated styles from an element using predefined style builder\n   * @protected\n   * @return {?}\n   */\n  clearStyles() {\n    Object.keys(this.mru).forEach(\n    /**\n    * @param {?} k\n    * @return {?}\n    */\n    k => {\n      this.mru[k] = '';\n    });\n    this.applyStyleToElement(this.mru);\n    this.mru = {};\n  }\n  /**\n   * Force trigger style updates on DOM element\n   * @protected\n   * @return {?}\n   */\n  triggerUpdate() {\n    this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY);\n  }\n  /**\n   * Determine the DOM element's Flexbox flow (flex-direction).\n   *\n   * Check inline style first then check computed (stylesheet) style.\n   * And optionally add the flow value to element's inline style.\n   * @protected\n   * @param {?} target\n   * @param {?=} addIfMissing\n   * @return {?}\n   */\n  getFlexFlowDirection(target, addIfMissing = false) {\n    if (target) {\n      const [value, hasInlineValue] = this.styler.getFlowDirection(target);\n      if (!hasInlineValue && addIfMissing) {\n        /** @type {?} */\n        const style = buildLayoutCSS(value);\n        /** @type {?} */\n        const elements = [target];\n        this.styler.applyStyleToElements(style, elements);\n      }\n      return value.trim();\n    }\n    return 'row';\n  }\n  /**\n   * @protected\n   * @param {?} target\n   * @return {?}\n   */\n  hasWrap(target) {\n    return this.styler.hasWrap(target);\n  }\n  /**\n   * Applies styles given via string pair or object map to the directive element\n   * @protected\n   * @param {?} style\n   * @param {?=} value\n   * @param {?=} element\n   * @return {?}\n   */\n  applyStyleToElement(style, value, element = this.nativeElement) {\n    this.styler.applyStyleToElement(element, style, value);\n  }\n  /**\n   * @protected\n   * @param {?} val\n   * @param {?} bp\n   * @return {?}\n   */\n  setValue(val, bp) {\n    this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, val, bp);\n  }\n  /**\n   * @protected\n   * @param {?} input\n   * @return {?}\n   */\n  updateWithValue(input) {\n    if (this.currentValue !== input) {\n      this.addStyles(input);\n      this.currentValue = input;\n    }\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/base/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/data/break-points.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * NOTE: Smaller ranges have HIGHER priority since the match is more specific\n * @type {?}\n */\nconst DEFAULT_BREAKPOINTS = [{\n  alias: 'xs',\n  mediaQuery: 'screen and (min-width: 0px) and (max-width: 599.98px)',\n  priority: 1000\n}, {\n  alias: 'sm',\n  mediaQuery: 'screen and (min-width: 600px) and (max-width: 959.98px)',\n  priority: 900\n}, {\n  alias: 'md',\n  mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279.98px)',\n  priority: 800\n}, {\n  alias: 'lg',\n  mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919.98px)',\n  priority: 700\n}, {\n  alias: 'xl',\n  mediaQuery: 'screen and (min-width: 1920px) and (max-width: 4999.98px)',\n  priority: 600\n}, {\n  alias: 'lt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 599.98px)',\n  priority: 950\n}, {\n  alias: 'lt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 959.98px)',\n  priority: 850\n}, {\n  alias: 'lt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 1279.98px)',\n  priority: 750\n}, {\n  alias: 'lt-xl',\n  overlapping: true,\n  priority: 650,\n  mediaQuery: 'screen and (max-width: 1919.98px)'\n}, {\n  alias: 'gt-xs',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 600px)',\n  priority: -950\n}, {\n  alias: 'gt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 960px)',\n  priority: -850\n}, {\n  alias: 'gt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1280px)',\n  priority: -750\n}, {\n  alias: 'gt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1920px)',\n  priority: -650\n}];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/data/orientation-break-points.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/* tslint:disable */\n/** @type {?} */\nconst HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599.98px)';\n/** @type {?} */\nconst HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959.98px)';\n/** @type {?} */\nconst TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)';\n/** @type {?} */\nconst TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)';\n/** @type {?} */\nconst WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';\n/** @type {?} */\nconst WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';\n/** @type {?} */\nconst ScreenTypes = {\n  'HANDSET': `${HANDSET_PORTRAIT}, ${HANDSET_LANDSCAPE}`,\n  'TABLET': `${TABLET_PORTRAIT} , ${TABLET_LANDSCAPE}`,\n  'WEB': `${WEB_PORTRAIT}, ${WEB_LANDSCAPE} `,\n  'HANDSET_PORTRAIT': `${HANDSET_PORTRAIT}`,\n  'TABLET_PORTRAIT': `${TABLET_PORTRAIT} `,\n  'WEB_PORTRAIT': `${WEB_PORTRAIT}`,\n  'HANDSET_LANDSCAPE': `${HANDSET_LANDSCAPE}`,\n  'TABLET_LANDSCAPE': `${TABLET_LANDSCAPE}`,\n  'WEB_LANDSCAPE': `${WEB_LANDSCAPE}`\n};\n/**\n * Extended Breakpoints for handset/tablets with landscape or portrait orientations\n * @type {?}\n */\nconst ORIENTATION_BREAKPOINTS = [{\n  'alias': 'handset',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET\n}, {\n  'alias': 'handset.landscape',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE\n}, {\n  'alias': 'handset.portrait',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_PORTRAIT\n}, {\n  'alias': 'tablet',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET\n}, {\n  'alias': 'tablet.landscape',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_LANDSCAPE\n}, {\n  'alias': 'tablet.portrait',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_PORTRAIT\n}, {\n  'alias': 'web',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB,\n  overlapping: true\n}, {\n  'alias': 'web.landscape',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_LANDSCAPE,\n  overlapping: true\n}, {\n  'alias': 'web.portrait',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_PORTRAIT,\n  overlapping: true\n}];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/break-point.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/object-extend.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n  if (dest == null) {\n    throw TypeError('Cannot convert undefined or null to object');\n  }\n  for (let source of sources) {\n    if (source != null) {\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = source[key];\n        }\n      }\n    }\n  }\n  return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/breakpoint-tools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALIAS_DELIMITERS = /(\\.|-|_)/g;\n/**\n * @param {?} part\n * @return {?}\n */\nfunction firstUpperCase(part) {\n  /** @type {?} */\n  let first = part.length > 0 ? part.charAt(0) : '';\n  /** @type {?} */\n  let remainder = part.length > 1 ? part.slice(1) : '';\n  return first.toUpperCase() + remainder;\n}\n/**\n * Converts snake-case to SnakeCase.\n * @param {?} name Text to UpperCamelCase\n * @return {?}\n */\nfunction camelCase(name) {\n  return name.replace(ALIAS_DELIMITERS, '|').split('|').map(firstUpperCase).join('');\n}\n/**\n * For each breakpoint, ensure that a Suffix is defined;\n * fallback to UpperCamelCase the unique Alias value\n * @param {?} list\n * @return {?}\n */\nfunction validateSuffixes(list) {\n  list.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  bp => {\n    if (!bp.suffix) {\n      bp.suffix = camelCase(bp.alias); // create Suffix value based on alias\n      bp.overlapping = !!bp.overlapping; // ensure default value\n    }\n  });\n\n  return list;\n}\n/**\n * Merge a custom breakpoint list with the default list based on unique alias values\n *  - Items are added if the alias is not in the default list\n *  - Items are merged with the custom override if the alias exists in the default list\n * @param {?} defaults\n * @param {?=} custom\n * @return {?}\n */\nfunction mergeByAlias(defaults, custom = []) {\n  /** @type {?} */\n  const dict = {};\n  defaults.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  bp => {\n    dict[bp.alias] = bp;\n  });\n  // Merge custom breakpoints\n  custom.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  bp => {\n    if (dict[bp.alias]) {\n      extendObject(dict[bp.alias], bp);\n    } else {\n      dict[bp.alias] = bp;\n    }\n  });\n  return validateSuffixes(Object.keys(dict).map(\n  /**\n  * @param {?} k\n  * @return {?}\n  */\n  k => dict[k]));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/break-points-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n *  Injection token unique to the flex-layout library.\n *  Use this token when build a custom provider (see below).\n * @type {?}\n */\nconst BREAKPOINTS = /*#__PURE__*/new InjectionToken('Token (@angular/flex-layout) Breakpoints', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => {\n    /** @type {?} */\n    const breakpoints = inject(BREAKPOINT);\n    /** @type {?} */\n    const layoutConfig = inject(LAYOUT_CONFIG);\n    /** @type {?} */\n    const bpFlattenArray = [].concat.apply([], (breakpoints || []).map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    v => Array.isArray(v) ? v : [v]));\n    /** @type {?} */\n    const builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS).concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);\n    return mergeByAlias(builtIns, bpFlattenArray);\n  }\n});\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/sort.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * HOF to sort the breakpoints by descending priority\n * @template T\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sortDescendingPriority(a, b) {\n  /** @type {?} */\n  const priorityA = a ? a.priority || 0 : 0;\n  /** @type {?} */\n  const priorityB = b ? b.priority || 0 : 0;\n  return priorityB - priorityA;\n}\n/**\n * HOF to sort the breakpoints by ascending priority\n * @template T\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sortAscendingPriority(a, b) {\n  /** @type {?} */\n  const pA = a.priority || 0;\n  /** @type {?} */\n  const pB = b.priority || 0;\n  return pA - pB;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/break-point-registry.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Registry of 1..n MediaQuery breakpoint ranges\n * This is published as a provider and may be overridden from custom, application-specific ranges\n *\n */\nlet BreakPointRegistry = /*#__PURE__*/(() => {\n  class BreakPointRegistry {\n    /**\n     * @param {?} list\n     */\n    constructor(list) {\n      /**\n       * Memoized BreakPoint Lookups\n       */\n      this.findByMap = new Map();\n      this.items = [...list].sort(sortAscendingPriority);\n    }\n    /**\n     * Search breakpoints by alias (e.g. gt-xs)\n     * @param {?} alias\n     * @return {?}\n     */\n    findByAlias(alias) {\n      return !alias ? null : this.findWithPredicate(alias,\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n      bp => bp.alias == alias);\n    }\n    /**\n     * @param {?} query\n     * @return {?}\n     */\n    findByQuery(query) {\n      return this.findWithPredicate(query,\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n      bp => bp.mediaQuery == query);\n    }\n    /**\n     * Get all the breakpoints whose ranges could overlapping `normal` ranges;\n     * e.g. gt-sm overlaps md, lg, and xl\n     * @return {?}\n     */\n    get overlappings() {\n      return this.items.filter(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      it => it.overlapping == true);\n    }\n    /**\n     * Get list of all registered (non-empty) breakpoint aliases\n     * @return {?}\n     */\n    get aliases() {\n      return this.items.map(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      it => it.alias);\n    }\n    /**\n     * Aliases are mapped to properties using suffixes\n     * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'\n     * for property layoutGtSM.\n     * @return {?}\n     */\n    get suffixes() {\n      return this.items.map(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      it => !!it.suffix ? it.suffix : '');\n    }\n    /**\n     * Memoized lookup using custom predicate function\n     * @private\n     * @param {?} key\n     * @param {?} searchFn\n     * @return {?}\n     */\n    findWithPredicate(key, searchFn) {\n      /** @type {?} */\n      let response = this.findByMap.get(key);\n      if (!response) {\n        response = this.items.find(searchFn) || null;\n        this.findByMap.set(key, response);\n      }\n      return response || null;\n    }\n  }\n  /** @nocollapse */BreakPointRegistry.ɵprov = ɵɵdefineInjectable({\n    factory: function BreakPointRegistry_Factory() {\n      return new BreakPointRegistry(ɵɵinject(BREAKPOINTS));\n    },\n    token: BreakPointRegistry,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return BreakPointRegistry;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * Generated from: core/match-media/match-media.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to\n * convert mediaQuery change callbacks to subscriber notifications. These notifications will be\n * performed within the ng Zone to trigger change detections and component updates.\n *\n * NOTE: both mediaQuery activations and de-activations are announced in notifications\n */\nlet MatchMedia = /*#__PURE__*/(() => {\n  class MatchMedia {\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    constructor(_zone, _platformId, _document) {\n      this._zone = _zone;\n      this._platformId = _platformId;\n      this._document = _document;\n      /**\n       * Initialize source with 'all' so all non-responsive APIs trigger style updates\n       */\n      this.source = new BehaviorSubject(new MediaChange(true));\n      this.registry = new Map();\n      this.pendingRemoveListenerFns = [];\n      this._observable$ = this.source.asObservable();\n    }\n    /**\n     * Publish list of all current activations\n     * @return {?}\n     */\n    get activations() {\n      /** @type {?} */\n      const results = [];\n      this.registry.forEach(\n      /**\n      * @param {?} mql\n      * @param {?} key\n      * @return {?}\n      */\n      (mql, key) => {\n        if (mql.matches) {\n          results.push(key);\n        }\n      });\n      return results;\n    }\n    /**\n     * For the specified mediaQuery?\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    isActive(mediaQuery) {\n      /** @type {?} */\n      const mql = this.registry.get(mediaQuery);\n      return !!mql ? mql.matches : this.registerQuery(mediaQuery).some(\n      /**\n      * @param {?} m\n      * @return {?}\n      */\n      m => m.matches);\n    }\n    /**\n     * External observers can watch for all (or a specific) mql changes.\n     * Typically used by the MediaQueryAdaptor; optionally available to components\n     * who wish to use the MediaMonitor as mediaMonitor$ observable service.\n     *\n     * Use deferred registration process to register breakpoints only on subscription\n     * This logic also enforces logic to register all mediaQueries BEFORE notify\n     * subscribers of notifications.\n     * @param {?=} mqList\n     * @param {?=} filterOthers\n     * @return {?}\n     */\n    observe(mqList, filterOthers = false) {\n      if (mqList && mqList.length) {\n        /** @type {?} */\n        const matchMedia$ = this._observable$.pipe(filter(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => !filterOthers ? true : mqList.indexOf(change.mediaQuery) > -1));\n        /** @type {?} */\n        const registration$ = new Observable(\n        /**\n        * @param {?} observer\n        * @return {?}\n        */\n        observer => {\n          // tslint:disable-line:max-line-length\n          /** @type {?} */\n          const matches = this.registerQuery(mqList);\n          if (matches.length) {\n            /** @type {?} */\n            const lastChange = /** @type {?} */matches.pop();\n            matches.forEach(\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            e => {\n              observer.next(e);\n            });\n            this.source.next(lastChange); // last match is cached\n          }\n\n          observer.complete();\n        });\n        return merge(registration$, matchMedia$);\n      }\n      return this._observable$;\n    }\n    /**\n     * Based on the BreakPointRegistry provider, register internal listeners for each unique\n     * mediaQuery. Each listener emits specific MediaChange data to observers\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    registerQuery(mediaQuery) {\n      /** @type {?} */\n      const list = Array.isArray(mediaQuery) ? mediaQuery : [mediaQuery];\n      /** @type {?} */\n      const matches = [];\n      buildQueryCss(list, this._document);\n      list.forEach(\n      /**\n      * @param {?} query\n      * @return {?}\n      */\n      query => {\n        /** @type {?} */\n        const onMQLEvent =\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        e => {\n          this._zone.run(\n          /**\n          * @return {?}\n          */\n          () => this.source.next(new MediaChange(e.matches, query)));\n        };\n        /** @type {?} */\n        let mql = this.registry.get(query);\n        if (!mql) {\n          mql = this.buildMQL(query);\n          mql.addListener(onMQLEvent);\n          this.pendingRemoveListenerFns.push(\n          /**\n          * @return {?}\n          */\n          () => /** @type {?} */mql.removeListener(onMQLEvent));\n          this.registry.set(query, mql);\n        }\n        if (mql.matches) {\n          matches.push(new MediaChange(true, query));\n        }\n      });\n      return matches;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      /** @type {?} */\n      let fn;\n      while (fn = this.pendingRemoveListenerFns.pop()) {\n        fn();\n      }\n    }\n    /**\n     * Call window.matchMedia() to build a MediaQueryList; which\n     * supports 0..n listeners for activation/deactivation\n     * @protected\n     * @param {?} query\n     * @return {?}\n     */\n    buildMQL(query) {\n      return constructMql(query, isPlatformBrowser(this._platformId));\n    }\n  }\n  /** @nocollapse */MatchMedia.ɵprov = ɵɵdefineInjectable({\n    factory: function MatchMedia_Factory() {\n      return new MatchMedia(ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT));\n    },\n    token: MatchMedia,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return MatchMedia;\n})();\n/**\n * Private global registry for all dynamically-created, injected style tags\n * @see prepare(query)\n * @type {?}\n */\nconst ALL_STYLES = {};\n/**\n * For Webkit engines that only trigger the MediaQueryList Listener\n * when there is at least one CSS selector for the respective media query.\n *\n * @param {?} mediaQueries\n * @param {?} _document\n * @return {?}\n */\nfunction buildQueryCss(mediaQueries, _document) {\n  /** @type {?} */\n  const list = mediaQueries.filter(\n  /**\n  * @param {?} it\n  * @return {?}\n  */\n  it => !ALL_STYLES[it]);\n  if (list.length > 0) {\n    /** @type {?} */\n    const query = list.join(', ');\n    try {\n      /** @type {?} */\n      const styleEl = _document.createElement('style');\n      styleEl.setAttribute('type', 'text/css');\n      if (! /** @type {?} */styleEl.styleSheet) {\n        /** @type {?} */\n        const cssText = `\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${query} {.fx-query-test{ }}\n`;\n        styleEl.appendChild(_document.createTextNode(cssText));\n      }\n      /** @type {?} */_document.head.appendChild(styleEl);\n      // Store in private global registry\n      list.forEach(\n      /**\n      * @param {?} mq\n      * @return {?}\n      */\n      mq => ALL_STYLES[mq] = styleEl);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n/**\n * @param {?} query\n * @param {?} isBrowser\n * @return {?}\n */\nfunction constructMql(query, isBrowser) {\n  /** @type {?} */\n  const canListen = isBrowser && !! /** @type {?} */window.matchMedia('all').addListener;\n  return canListen ? /** @type {?} */window.matchMedia(query) : /** @type {?} */{\n    matches: query === 'all' || query === '',\n    media: query,\n    addListener:\n    /**\n    * @return {?}\n    */\n    () => {},\n    removeListener:\n    /**\n    * @return {?}\n    */\n    () => {},\n    onchange: null,\n    /**\n     * @return {?}\n     */\n    addEventListener() {},\n    /**\n     * @return {?}\n     */\n    removeEventListener() {},\n    /**\n     * @return {?}\n     */\n    dispatchEvent() {\n      return false;\n    }\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/match-media/mock/mock-match-media.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated\n * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery\n * range and to clearAll mediaQuery listeners.\n */\nclass MockMatchMedia extends MatchMedia {\n  // Allow fallback to overlapping mediaQueries\n  /**\n   * @param {?} _zone\n   * @param {?} _platformId\n   * @param {?} _document\n   * @param {?} _breakpoints\n   */\n  constructor(_zone, _platformId, _document, _breakpoints) {\n    super(_zone, _platformId, _document);\n    this._breakpoints = _breakpoints;\n    this.autoRegisterQueries = true; // Used for testing BreakPoint registrations\n    // Used for testing BreakPoint registrations\n    this.useOverlaps = false; // Allow fallback to overlapping mediaQueries\n  }\n  /**\n   * Easy method to clear all listeners for all mediaQueries\n   * @return {?}\n   */\n  clearAll() {\n    this.registry.forEach(\n    /**\n    * @param {?} mql\n    * @return {?}\n    */\n    mql => {\n      /** @type {?} */mql.destroy();\n    });\n    this.registry.clear();\n    this.useOverlaps = false;\n  }\n  /**\n   * Feature to support manual, simulated activation of a mediaQuery.\n   * @param {?} mediaQuery\n   * @param {?=} useOverlaps\n   * @return {?}\n   */\n  activate(mediaQuery, useOverlaps = false) {\n    useOverlaps = useOverlaps || this.useOverlaps;\n    mediaQuery = this._validateQuery(mediaQuery);\n    if (useOverlaps || !this.isActive(mediaQuery)) {\n      this._deactivateAll();\n      this._registerMediaQuery(mediaQuery);\n      this._activateWithOverlaps(mediaQuery, useOverlaps);\n    }\n    return this.hasActivated;\n  }\n  /**\n   * Converts an optional mediaQuery alias to a specific, valid mediaQuery\n   * @param {?} queryOrAlias\n   * @return {?}\n   */\n  _validateQuery(queryOrAlias) {\n    /** @type {?} */\n    const bp = this._breakpoints.findByAlias(queryOrAlias);\n    return bp && bp.mediaQuery || queryOrAlias;\n  }\n  /**\n   * Manually onMediaChange any overlapping mediaQueries to simulate\n   * similar functionality in the window.matchMedia()\n   * @private\n   * @param {?} mediaQuery\n   * @param {?} useOverlaps\n   * @return {?}\n   */\n  _activateWithOverlaps(mediaQuery, useOverlaps) {\n    if (useOverlaps) {\n      /** @type {?} */\n      const bp = this._breakpoints.findByQuery(mediaQuery);\n      /** @type {?} */\n      const alias = bp ? bp.alias : 'unknown';\n      // Simulate activation of overlapping lt-<XXX> ranges\n      switch (alias) {\n        case 'lg':\n          this._activateByAlias(['lt-xl']);\n          break;\n        case 'md':\n          this._activateByAlias(['lt-xl', 'lt-lg']);\n          break;\n        case 'sm':\n          this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md']);\n          break;\n        case 'xs':\n          this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md', 'lt-sm']);\n          break;\n      }\n      // Simulate activation of overlapping gt-<xxxx> mediaQuery ranges\n      switch (alias) {\n        case 'xl':\n          this._activateByAlias(['gt-lg', 'gt-md', 'gt-sm', 'gt-xs']);\n          break;\n        case 'lg':\n          this._activateByAlias(['gt-md', 'gt-sm', 'gt-xs']);\n          break;\n        case 'md':\n          this._activateByAlias(['gt-sm', 'gt-xs']);\n          break;\n        case 'sm':\n          this._activateByAlias(['gt-xs']);\n          break;\n      }\n    }\n    // Activate last since the responsiveActivation is watching *this* mediaQuery\n    return this._activateByQuery(mediaQuery);\n  }\n  /**\n   *\n   * @private\n   * @param {?} aliases\n   * @return {?}\n   */\n  _activateByAlias(aliases) {\n    /** @type {?} */\n    const activate =\n    /**\n    * @param {?} alias\n    * @return {?}\n    */\n    alias => {\n      /** @type {?} */\n      const bp = this._breakpoints.findByAlias(alias);\n      this._activateByQuery(bp ? bp.mediaQuery : alias);\n    };\n    aliases.forEach(activate);\n  }\n  /**\n   *\n   * @private\n   * @param {?} mediaQuery\n   * @return {?}\n   */\n  _activateByQuery(mediaQuery) {\n    if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n      this._registerMediaQuery(mediaQuery);\n    }\n    /** @type {?} */\n    const mql = /** @type {?} */this.registry.get(mediaQuery);\n    if (mql && !this.isActive(mediaQuery)) {\n      this.registry.set(mediaQuery, mql.activate());\n    }\n    return this.hasActivated;\n  }\n  /**\n   * Deactivate all current MQLs and reset the buffer\n   * @private\n   * @template THIS\n   * @this {THIS}\n   * @return {THIS}\n   */\n  _deactivateAll() {\n    /** @type {?} */this.registry.forEach(\n    /**\n    * @param {?} it\n    * @return {?}\n    */\n    it => {\n      /** @type {?} */it.deactivate();\n    });\n    return (/** @type {?} */this\n    );\n  }\n  /**\n   * Insure the mediaQuery is registered with MatchMedia\n   * @private\n   * @param {?} mediaQuery\n   * @return {?}\n   */\n  _registerMediaQuery(mediaQuery) {\n    if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n      this.registerQuery(mediaQuery);\n    }\n  }\n  /**\n   * Call window.matchMedia() to build a MediaQueryList; which\n   * supports 0..n listeners for activation/deactivation\n   * @protected\n   * @param {?} query\n   * @return {?}\n   */\n  buildMQL(query) {\n    return new MockMediaQueryList(query);\n  }\n  /**\n   * @protected\n   * @return {?}\n   */\n  get hasActivated() {\n    return this.activations.length > 0;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * Special internal class to simulate a MediaQueryList and\n * - supports manual activation to simulate mediaQuery matching\n * - manages listeners\n */\nclass MockMediaQueryList {\n  /**\n   * @param {?} _mediaQuery\n   */\n  constructor(_mediaQuery) {\n    this._mediaQuery = _mediaQuery;\n    this._isActive = false;\n    this._listeners = [];\n    this.onchange = null;\n  }\n  /**\n   * @return {?}\n   */\n  get matches() {\n    return this._isActive;\n  }\n  /**\n   * @return {?}\n   */\n  get media() {\n    return this._mediaQuery;\n  }\n  /**\n   * Destroy the current list by deactivating the\n   * listeners and clearing the internal list\n   * @return {?}\n   */\n  destroy() {\n    this.deactivate();\n    this._listeners = [];\n  }\n  /**\n   * Notify all listeners that 'matches === TRUE'\n   * @return {?}\n   */\n  activate() {\n    if (!this._isActive) {\n      this._isActive = true;\n      this._listeners.forEach(\n      /**\n      * @param {?} callback\n      * @return {?}\n      */\n      callback => {\n        /** @type {?} */\n        const cb = /** @type {?} */callback;\n        cb.call(this, /** @type {?} */{\n          matches: this.matches,\n          media: this.media\n        });\n      });\n    }\n    return this;\n  }\n  /**\n   * Notify all listeners that 'matches === false'\n   * @return {?}\n   */\n  deactivate() {\n    if (this._isActive) {\n      this._isActive = false;\n      this._listeners.forEach(\n      /**\n      * @param {?} callback\n      * @return {?}\n      */\n      callback => {\n        /** @type {?} */\n        const cb = /** @type {?} */callback;\n        cb.call(this, /** @type {?} */{\n          matches: this.matches,\n          media: this.media\n        });\n      });\n    }\n    return this;\n  }\n  /**\n   * Add a listener to our internal list to activate later\n   * @param {?} listener\n   * @return {?}\n   */\n  addListener(listener) {\n    if (this._listeners.indexOf(listener) === -1) {\n      this._listeners.push(listener);\n    }\n    if (this._isActive) {\n      /** @type {?} */\n      const cb = /** @type {?} */listener;\n      cb.call(this, /** @type {?} */{\n        matches: this.matches,\n        media: this.media\n      });\n    }\n  }\n  /**\n   * Don't need to remove listeners in the testing environment\n   * @param {?} _\n   * @return {?}\n   */\n  removeListener(_) {}\n  /**\n   * @param {?} _\n   * @param {?} __\n   * @param {?=} ___\n   * @return {?}\n   */\n  addEventListener(_, __, ___) {}\n  /**\n   * @param {?} _\n   * @param {?} __\n   * @param {?=} ___\n   * @return {?}\n   */\n  removeEventListener(_, __, ___) {}\n  /**\n   * @param {?} _\n   * @return {?}\n   */\n  dispatchEvent(_) {\n    return false;\n  }\n}\n/**\n * Pre-configured provider for MockMatchMedia\n * @type {?}\n */\nconst MockMatchMediaProvider = {\n  // tslint:disable-line:variable-name\n  provide: MatchMedia,\n  useClass: MockMatchMedia\n};\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/match-media/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-marshaller/print-hook.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst PRINT = 'print';\n/** @type {?} */\nconst BREAKPOINT_PRINT = {\n  alias: PRINT,\n  mediaQuery: PRINT,\n  priority: 1000\n};\n/**\n * PrintHook - Use to intercept print MediaQuery activations and force\n *             layouts to render with the specified print alias/breakpoint\n *\n * Used in MediaMarshaller and MediaObserver\n */\nlet PrintHook = /*#__PURE__*/(() => {\n  class PrintHook {\n    /**\n     * @param {?} breakpoints\n     * @param {?} layoutConfig\n     * @param {?} _document\n     */\n    constructor(breakpoints, layoutConfig, _document) {\n      this.breakpoints = breakpoints;\n      this.layoutConfig = layoutConfig;\n      this._document = _document;\n      // registeredBeforeAfterPrintHooks tracks if we registered the `beforeprint`\n      //  and `afterprint` event listeners.\n      this.registeredBeforeAfterPrintHooks = false;\n      // isPrintingBeforeAfterEvent is used to track if we are printing from within\n      // a `beforeprint` event handler. This prevents the typicall `stopPrinting`\n      // form `interceptEvents` so that printing is not stopped while the dialog\n      // is still open. This is an extension of the `isPrinting` property on\n      // browsers which support `beforeprint` and `afterprint` events.\n      this.isPrintingBeforeAfterEvent = false;\n      this.beforePrintEventListeners = [];\n      this.afterPrintEventListeners = [];\n      /**\n       * Is this service currently in Print-mode ?\n       */\n      this.isPrinting = false;\n      this.queue = new PrintQueue();\n      this.deactivations = [];\n    }\n    /**\n     * Add 'print' mediaQuery: to listen for matchMedia activations\n     * @param {?} queries\n     * @return {?}\n     */\n    withPrintQuery(queries) {\n      return [...queries, PRINT];\n    }\n    /**\n     * Is the MediaChange event for any 'print' \\@media\n     * @param {?} e\n     * @return {?}\n     */\n    isPrintEvent(e) {\n      return e.mediaQuery.startsWith(PRINT);\n    }\n    /**\n     * What is the desired mqAlias to use while printing?\n     * @return {?}\n     */\n    get printAlias() {\n      return this.layoutConfig.printWithBreakpoints || [];\n    }\n    /**\n     * Lookup breakpoints associated with print aliases.\n     * @return {?}\n     */\n    get printBreakPoints() {\n      return (/** @type {?} */this.printAlias.map(\n        /**\n        * @param {?} alias\n        * @return {?}\n        */\n        alias => this.breakpoints.findByAlias(alias)).filter(\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n        bp => bp !== null)\n      );\n    }\n    /**\n     * Lookup breakpoint associated with mediaQuery\n     * @param {?} __0\n     * @return {?}\n     */\n    getEventBreakpoints({\n      mediaQuery\n    }) {\n      /** @type {?} */\n      const bp = this.breakpoints.findByQuery(mediaQuery);\n      /** @type {?} */\n      const list = bp ? [...this.printBreakPoints, bp] : this.printBreakPoints;\n      return list.sort(sortDescendingPriority);\n    }\n    /**\n     * Update event with printAlias mediaQuery information\n     * @param {?} event\n     * @return {?}\n     */\n    updateEvent(event) {\n      /** @type {?} */\n      let bp = this.breakpoints.findByQuery(event.mediaQuery);\n      if (this.isPrintEvent(event)) {\n        // Reset from 'print' to first (highest priority) print breakpoint\n        bp = this.getEventBreakpoints(event)[0];\n        event.mediaQuery = bp ? bp.mediaQuery : '';\n      }\n      return mergeAlias(event, bp);\n    }\n    // registerBeforeAfterPrintHooks registers a `beforeprint` event hook so we can\n    // trigger print styles synchronously and apply proper layout styles.\n    // It is a noop if the hooks have already been registered or if the document's\n    // `defaultView` is not available.\n    /**\n     * @private\n     * @param {?} target\n     * @return {?}\n     */\n    registerBeforeAfterPrintHooks(target) {\n      // `defaultView` may be null when rendering on the server or in other contexts.\n      if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) {\n        return;\n      }\n      this.registeredBeforeAfterPrintHooks = true;\n      /** @type {?} */\n      const beforePrintListener =\n      /**\n      * @return {?}\n      */\n      () => {\n        // If we aren't already printing, start printing and update the styles as\n        // if there was a regular print `MediaChange`(from matchMedia).\n        if (!this.isPrinting) {\n          this.isPrintingBeforeAfterEvent = true;\n          this.startPrinting(target, this.getEventBreakpoints(new MediaChange(true, PRINT)));\n          target.updateStyles();\n        }\n      };\n      /** @type {?} */\n      const afterPrintListener =\n      /**\n      * @return {?}\n      */\n      () => {\n        // If we aren't already printing, start printing and update the styles as\n        // if there was a regular print `MediaChange`(from matchMedia).\n        this.isPrintingBeforeAfterEvent = false;\n        if (this.isPrinting) {\n          this.stopPrinting(target);\n          target.updateStyles();\n        }\n      };\n      // Could we have teardown logic to remove if there are no print listeners being used?\n      this._document.defaultView.addEventListener('beforeprint', beforePrintListener);\n      this._document.defaultView.addEventListener('afterprint', afterPrintListener);\n      this.beforePrintEventListeners.push(beforePrintListener);\n      this.afterPrintEventListeners.push(afterPrintListener);\n    }\n    /**\n     * Prepare RxJS filter operator with partial application\n     * @param {?} target\n     * @return {?} pipeable filter predicate\n     */\n    interceptEvents(target) {\n      this.registerBeforeAfterPrintHooks(target);\n      return (\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          if (this.isPrintEvent(event)) {\n            if (event.matches && !this.isPrinting) {\n              this.startPrinting(target, this.getEventBreakpoints(event));\n              target.updateStyles();\n            } else if (!event.matches && this.isPrinting && !this.isPrintingBeforeAfterEvent) {\n              this.stopPrinting(target);\n              target.updateStyles();\n            }\n          } else {\n            this.collectActivations(event);\n          }\n        }\n      );\n    }\n    /**\n     * Stop mediaChange event propagation in event streams\n     * @return {?}\n     */\n    blockPropagation() {\n      return (\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          return !(this.isPrinting || this.isPrintEvent(event));\n        }\n      );\n    }\n    /**\n     * Save current activateBreakpoints (for later restore)\n     * and substitute only the printAlias breakpoint\n     * @protected\n     * @param {?} target\n     * @param {?} bpList\n     * @return {?}\n     */\n    startPrinting(target, bpList) {\n      this.isPrinting = true;\n      target.activatedBreakpoints = this.queue.addPrintBreakpoints(bpList);\n    }\n    /**\n     * For any print de-activations, reset the entire print queue\n     * @protected\n     * @param {?} target\n     * @return {?}\n     */\n    stopPrinting(target) {\n      target.activatedBreakpoints = this.deactivations;\n      this.deactivations = [];\n      this.queue.clear();\n      this.isPrinting = false;\n    }\n    /**\n     * To restore pre-Print Activations, we must capture the proper\n     * list of breakpoint activations BEFORE print starts. OnBeforePrint()\n     * is supported; so 'print' mediaQuery activations are used as a fallback\n     * in browsers without `beforeprint` support.\n     *\n     * >  But activated breakpoints are deactivated BEFORE 'print' activation.\n     *\n     * Let's capture all de-activations using the following logic:\n     *\n     *  When not printing:\n     *    - clear cache when activating non-print breakpoint\n     *    - update cache (and sort) when deactivating\n     *\n     *  When printing:\n     *    - sort and save when starting print\n     *    - restore as activatedTargets and clear when stop printing\n     * @param {?} event\n     * @return {?}\n     */\n    collectActivations(event) {\n      if (!this.isPrinting || this.isPrintingBeforeAfterEvent) {\n        if (!event.matches) {\n          /** @type {?} */\n          const bp = this.breakpoints.findByQuery(event.mediaQuery);\n          if (bp) {\n            // Deactivating a breakpoint\n            this.deactivations.push(bp);\n            this.deactivations.sort(sortDescendingPriority);\n          }\n        } else if (!this.isPrintingBeforeAfterEvent) {\n          // Only clear deactivations if we aren't printing from a `beforeprint` event.\n          // Otherwise this will clear before `stopPrinting()` is called to restore\n          // the pre-Print Activations.\n          this.deactivations = [];\n        }\n      }\n    }\n    /**\n     * Teardown logic for the service.\n     * @return {?}\n     */\n    ngOnDestroy() {\n      if (this._document.defaultView) {\n        this.beforePrintEventListeners.forEach(\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n        l => this._document.defaultView.removeEventListener('beforeprint', l));\n        this.afterPrintEventListeners.forEach(\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n        l => this._document.defaultView.removeEventListener('afterprint', l));\n      }\n    }\n  }\n  /** @nocollapse */PrintHook.ɵprov = ɵɵdefineInjectable({\n    factory: function PrintHook_Factory() {\n      return new PrintHook(ɵɵinject(BreakPointRegistry), ɵɵinject(LAYOUT_CONFIG), ɵɵinject(DOCUMENT));\n    },\n    token: PrintHook,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return PrintHook;\n})();\n// ************************************************************************\n// Internal Utility class 'PrintQueue'\n// ************************************************************************\n/**\n * Utility class to manage print breakpoints + activatedBreakpoints\n * with correct sorting WHILE printing\n */\nclass PrintQueue {\n  constructor() {\n    /**\n     * Sorted queue with prioritized print breakpoints\n     */\n    this.printBreakpoints = [];\n  }\n  /**\n   * @param {?} bpList\n   * @return {?}\n   */\n  addPrintBreakpoints(bpList) {\n    bpList.push(BREAKPOINT_PRINT);\n    bpList.sort(sortDescendingPriority);\n    bpList.forEach(\n    /**\n    * @param {?} bp\n    * @return {?}\n    */\n    bp => this.addBreakpoint(bp));\n    return this.printBreakpoints;\n  }\n  /**\n   * Add Print breakpoint to queue\n   * @param {?} bp\n   * @return {?}\n   */\n  addBreakpoint(bp) {\n    if (!!bp) {\n      /** @type {?} */\n      const bpInList = this.printBreakpoints.find(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      it => it.mediaQuery === bp.mediaQuery);\n      if (bpInList === undefined) {\n        // If this is a `printAlias` breakpoint, then append. If a true 'print' breakpoint,\n        // register as highest priority in the queue\n        this.printBreakpoints = isPrintBreakPoint(bp) ? [bp, ...this.printBreakpoints] : [...this.printBreakpoints, bp];\n      }\n    }\n  }\n  /**\n   * Restore original activated breakpoints and clear internal caches\n   * @return {?}\n   */\n  clear() {\n    this.printBreakpoints = [];\n  }\n}\n// ************************************************************************\n// Internal Utility methods\n// ************************************************************************\n/**\n * Only support intercept queueing if the Breakpoint is a print \\@media query\n * @param {?} bp\n * @return {?}\n */\nfunction isPrintBreakPoint(bp) {\n  return bp ? bp.mediaQuery.startsWith(PRINT) : false;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/array.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-observer/media-observer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * MediaObserver enables applications to listen for 1..n mediaQuery activations and to determine\n * if a mediaQuery is currently activated.\n *\n * Since a breakpoint change will first deactivate 1...n mediaQueries and then possibly activate\n * 1..n mediaQueries, the MediaObserver will debounce notifications and report ALL *activations*\n * in 1 event notification. The reported activations will be sorted in descending priority order.\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * Note: Developers should note that only mediaChange activations (not de-activations)\n *       are announced by the MediaObserver.\n *\n * \\@usage\n *\n *  // RxJS\n *  import { filter } from 'rxjs/operators';\n *  import { MediaObserver } from '\\@angular/flex-layout';\n *\n * \\@Component({ ... })\n *  export class AppComponent {\n *    status: string = '';\n *\n *    constructor(mediaObserver: MediaObserver) {\n *      const media$ = mediaObserver.asObservable().pipe(\n *        filter((changes: MediaChange[]) => true)   // silly noop filter\n *      );\n *\n *      media$.subscribe((changes: MediaChange[]) => {\n *        let status = '';\n *        changes.forEach( change => {\n *          status += `'${change.mqAlias}' = (${change.mediaQuery}) <br/>` ;\n *        });\n *        this.status = status;\n *     });\n *\n *    }\n *  }\n */\nlet MediaObserver = /*#__PURE__*/(() => {\n  class MediaObserver {\n    /**\n     * @param {?} breakpoints\n     * @param {?} matchMedia\n     * @param {?} hook\n     */\n    constructor(breakpoints, matchMedia, hook) {\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.hook = hook;\n      /**\n       * Filter MediaChange notifications for overlapping breakpoints\n       */\n      this.filterOverlaps = false;\n      this.destroyed$ = new Subject();\n      this._media$ = this.watchActivations();\n      this.media$ = this._media$.pipe(filter(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      changes => changes.length > 0), map(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      changes => changes[0]));\n    }\n    /**\n     * Completes the active subject, signalling to all complete for all\n     * MediaObserver subscribers\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.destroyed$.next();\n      this.destroyed$.complete();\n    }\n    // ************************************************\n    // Public Methods\n    // ************************************************\n    /**\n     * Observe changes to current activation 'list'\n     * @return {?}\n     */\n    asObservable() {\n      return this._media$;\n    }\n    /**\n     * Allow programmatic query to determine if one or more media query/alias match\n     * the current viewport size.\n     * @param {?} value One or more media queries (or aliases) to check.\n     * @return {?} Whether any of the media queries match.\n     */\n    isActive(value) {\n      /** @type {?} */\n      const aliases = splitQueries(coerceArray(value));\n      return aliases.some(\n      /**\n      * @param {?} alias\n      * @return {?}\n      */\n      alias => {\n        /** @type {?} */\n        const query = toMediaQuery(alias, this.breakpoints);\n        return query !== null && this.matchMedia.isActive(query);\n      });\n    }\n    // ************************************************\n    // Internal Methods\n    // ************************************************\n    /**\n     * Register all the mediaQueries registered in the BreakPointRegistry\n     * This is needed so subscribers can be auto-notified of all standard, registered\n     * mediaQuery activations\n     * @private\n     * @return {?}\n     */\n    watchActivations() {\n      /** @type {?} */\n      const queries = this.breakpoints.items.map(\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n      bp => bp.mediaQuery);\n      return this.buildObservable(queries);\n    }\n    /**\n     * Only pass/announce activations (not de-activations)\n     *\n     * Since multiple-mediaQueries can be activation in a cycle,\n     * gather all current activations into a single list of changes to observers\n     *\n     * Inject associated (if any) alias information into the MediaChange event\n     * - Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n     * - Exclude print activations that do not have an associated mediaQuery\n     *\n     * NOTE: the raw MediaChange events [from MatchMedia] do not\n     *       contain important alias information; as such this info\n     *       must be injected into the MediaChange\n     * @private\n     * @param {?} mqList\n     * @return {?}\n     */\n    buildObservable(mqList) {\n      /** @type {?} */\n      const hasChanges =\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      changes => {\n        /** @type {?} */\n        const isValidQuery =\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => change.mediaQuery.length > 0;\n        return changes.filter(isValidQuery).length > 0;\n      };\n      /** @type {?} */\n      const excludeOverlaps =\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      changes => {\n        return !this.filterOverlaps ? changes : changes.filter(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => {\n          /** @type {?} */\n          const bp = this.breakpoints.findByQuery(change.mediaQuery);\n          return !bp ? true : !bp.overlapping;\n        });\n      };\n      /**\n       */\n      return this.matchMedia.observe(this.hook.withPrintQuery(mqList)).pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => change.matches), debounceTime(0, asapScheduler), switchMap(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => of(this.findAllActivations())), map(excludeOverlaps), filter(hasChanges), takeUntil(this.destroyed$));\n    }\n    /**\n     * Find all current activations and prepare single list of activations\n     * sorted by descending priority.\n     * @private\n     * @return {?}\n     */\n    findAllActivations() {\n      /** @type {?} */\n      const mergeMQAlias =\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => {\n        /** @type {?} */\n        let bp = this.breakpoints.findByQuery(change.mediaQuery);\n        return mergeAlias(change, bp);\n      };\n      /** @type {?} */\n      const replaceWithPrintAlias =\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      change => {\n        return this.hook.isPrintEvent(change) ? this.hook.updateEvent(change) : change;\n      };\n      return this.matchMedia.activations.map(\n      /**\n      * @param {?} query\n      * @return {?}\n      */\n      query => new MediaChange(true, query)).map(replaceWithPrintAlias).map(mergeMQAlias).sort(sortDescendingPriority);\n    }\n  }\n  /** @nocollapse */MediaObserver.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaObserver_Factory() {\n      return new MediaObserver(ɵɵinject(BreakPointRegistry), ɵɵinject(MatchMedia), ɵɵinject(PrintHook));\n    },\n    token: MediaObserver,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return MediaObserver;\n})();\n/**\n * Find associated breakpoint (if any)\n * @param {?} query\n * @param {?} locator\n * @return {?}\n */\nfunction toMediaQuery(query, locator) {\n  /** @type {?} */\n  const bp = locator.findByAlias(query) || locator.findByQuery(query);\n  return bp ? bp.mediaQuery : null;\n}\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n * @param {?} queries\n * @return {?}\n */\nfunction splitQueries(queries) {\n  return queries.map(\n  /**\n  * @param {?} query\n  * @return {?}\n  */\n  query => query.split(',')).reduce(\n  /**\n  * @param {?} a1\n  * @param {?} a2\n  * @return {?}\n  */\n  (a1, a2) => a1.concat(a2)).map(\n  /**\n  * @param {?} query\n  * @return {?}\n  */\n  query => query.trim());\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-observer/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-trigger/media-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Class\n */\nlet MediaTrigger = /*#__PURE__*/(() => {\n  class MediaTrigger {\n    /**\n     * @param {?} breakpoints\n     * @param {?} matchMedia\n     * @param {?} layoutConfig\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    constructor(breakpoints, matchMedia, layoutConfig, _platformId, _document) {\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.layoutConfig = layoutConfig;\n      this._platformId = _platformId;\n      this._document = _document;\n      this.hasCachedRegistryMatches = false;\n      this.originalActivations = [];\n      this.originalRegistry = new Map();\n    }\n    /**\n     * Manually activate range of breakpoints\n     * @param {?} list array of mediaQuery or alias strings\n     * @return {?}\n     */\n    activate(list) {\n      list = list.map(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      it => it.trim()); // trim queries\n      this.saveActivations();\n      this.deactivateAll();\n      this.setActivations(list);\n      this.prepareAutoRestore();\n    }\n    /**\n     * Restore original, 'real' breakpoints and emit events\n     * to trigger stream notification\n     * @return {?}\n     */\n    restore() {\n      if (this.hasCachedRegistryMatches) {\n        /** @type {?} */\n        const extractQuery =\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => change.mediaQuery;\n        /** @type {?} */\n        const list = this.originalActivations.map(extractQuery);\n        try {\n          this.deactivateAll();\n          this.restoreRegistryMatches();\n          this.setActivations(list);\n        } finally {\n          this.originalActivations = [];\n          if (this.resizeSubscription) {\n            this.resizeSubscription.unsubscribe();\n          }\n        }\n      }\n    }\n    // ************************************************\n    // Internal Methods\n    // ************************************************\n    /**\n     * Whenever window resizes, immediately auto-restore original\n     * activations (if we are simulating activations)\n     * @private\n     * @return {?}\n     */\n    prepareAutoRestore() {\n      /** @type {?} */\n      const isBrowser = isPlatformBrowser(this._platformId) && this._document;\n      /** @type {?} */\n      const enableAutoRestore = isBrowser && this.layoutConfig.mediaTriggerAutoRestore;\n      if (enableAutoRestore) {\n        /** @type {?} */\n        const resize$ = fromEvent(window, 'resize').pipe(take(1));\n        this.resizeSubscription = resize$.subscribe(this.restore.bind(this));\n      }\n    }\n    /**\n     * Notify all matchMedia subscribers of de-activations\n     *\n     * Note: we must force 'matches' updates for\n     *       future matchMedia::activation lookups\n     * @private\n     * @return {?}\n     */\n    deactivateAll() {\n      /** @type {?} */\n      const list = this.currentActivations;\n      this.forceRegistryMatches(list, false);\n      this.simulateMediaChanges(list, false);\n    }\n    /**\n     * Cache current activations as sorted, prioritized list of MediaChanges\n     * @private\n     * @return {?}\n     */\n    saveActivations() {\n      if (!this.hasCachedRegistryMatches) {\n        /** @type {?} */\n        const toMediaChange =\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        query => new MediaChange(true, query);\n        /** @type {?} */\n        const mergeMQAlias =\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        change => {\n          /** @type {?} */\n          const bp = this.breakpoints.findByQuery(change.mediaQuery);\n          return mergeAlias(change, bp);\n        };\n        this.originalActivations = this.currentActivations.map(toMediaChange).map(mergeMQAlias).sort(sortDescendingPriority);\n        this.cacheRegistryMatches();\n      }\n    }\n    /**\n     * Force set manual activations for specified mediaQuery list\n     * @private\n     * @param {?} list\n     * @return {?}\n     */\n    setActivations(list) {\n      if (!!this.originalRegistry) {\n        this.forceRegistryMatches(list, true);\n      }\n      this.simulateMediaChanges(list);\n    }\n    /**\n     * For specified mediaQuery list manually simulate activations or deactivations\n     * @private\n     * @param {?} queries\n     * @param {?=} matches\n     * @return {?}\n     */\n    simulateMediaChanges(queries, matches = true) {\n      /** @type {?} */\n      const toMediaQuery =\n      /**\n      * @param {?} query\n      * @return {?}\n      */\n      query => {\n        /** @type {?} */\n        const locator = this.breakpoints;\n        /** @type {?} */\n        const bp = locator.findByAlias(query) || locator.findByQuery(query);\n        return bp ? bp.mediaQuery : query;\n      };\n      /** @type {?} */\n      const emitChangeEvent =\n      /**\n      * @param {?} query\n      * @return {?}\n      */\n      query => this.emitChangeEvent(matches, query);\n      queries.map(toMediaQuery).forEach(emitChangeEvent);\n    }\n    /**\n     * Replace current registry with simulated registry...\n     * Note: this is required since MediaQueryList::matches is 'readOnly'\n     * @private\n     * @param {?} queries\n     * @param {?} matches\n     * @return {?}\n     */\n    forceRegistryMatches(queries, matches) {\n      /** @type {?} */\n      const registry = new Map();\n      queries.forEach(\n      /**\n      * @param {?} query\n      * @return {?}\n      */\n      query => {\n        registry.set(query, /** @type {?} */{\n          matches\n        });\n      });\n      this.matchMedia.registry = registry;\n    }\n    /**\n     * Save current MatchMedia::registry items.\n     * @private\n     * @return {?}\n     */\n    cacheRegistryMatches() {\n      /** @type {?} */\n      const target = this.originalRegistry;\n      target.clear();\n      this.matchMedia.registry.forEach(\n      /**\n      * @param {?} value\n      * @param {?} key\n      * @return {?}\n      */\n      (value, key) => {\n        target.set(key, value);\n      });\n      this.hasCachedRegistryMatches = true;\n    }\n    /**\n     * Restore original, 'true' registry\n     * @private\n     * @return {?}\n     */\n    restoreRegistryMatches() {\n      /** @type {?} */\n      const target = this.matchMedia.registry;\n      target.clear();\n      this.originalRegistry.forEach(\n      /**\n      * @param {?} value\n      * @param {?} key\n      * @return {?}\n      */\n      (value, key) => {\n        target.set(key, value);\n      });\n      this.originalRegistry.clear();\n      this.hasCachedRegistryMatches = false;\n    }\n    /**\n     * Manually emit a MediaChange event via the MatchMedia to MediaMarshaller and MediaObserver\n     * @private\n     * @param {?} matches\n     * @param {?} query\n     * @return {?}\n     */\n    emitChangeEvent(matches, query) {\n      this.matchMedia.source.next(new MediaChange(matches, query));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    get currentActivations() {\n      return this.matchMedia.activations;\n    }\n  }\n  /** @nocollapse */MediaTrigger.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaTrigger_Factory() {\n      return new MediaTrigger(ɵɵinject(BreakPointRegistry), ɵɵinject(MatchMedia), ɵɵinject(LAYOUT_CONFIG), ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT));\n    },\n    token: MediaTrigger,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return MediaTrigger;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-trigger/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/auto-prefixer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Applies CSS prefixes to appropriate style keys.\n *\n * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.\n *    {\n *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10\n *      display: flex;             NEW, Spec - Firefox, Chrome, Opera\n *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7\n *      // display: -ms-flexbox;   TWEENER - IE 10\n *      // display: -moz-flexbox;  OLD - Firefox\n *    }\n * @param {?} target\n * @return {?}\n */\nfunction applyCssPrefixes(target) {\n  for (let key in target) {\n    /** @type {?} */\n    let value = target[key] || '';\n    switch (key) {\n      case 'display':\n        if (value === 'flex') {\n          target['display'] = ['-webkit-flex', 'flex'];\n        } else if (value === 'inline-flex') {\n          target['display'] = ['-webkit-inline-flex', 'inline-flex'];\n        } else {\n          target['display'] = value;\n        }\n        break;\n      case 'align-items':\n      case 'align-self':\n      case 'align-content':\n      case 'flex':\n      case 'flex-basis':\n      case 'flex-flow':\n      case 'flex-grow':\n      case 'flex-shrink':\n      case 'flex-wrap':\n      case 'justify-content':\n        target['-webkit-' + key] = value;\n        break;\n      case 'flex-direction':\n        value = value || 'row';\n        target['-webkit-flex-direction'] = value;\n        target['flex-direction'] = value;\n        break;\n      case 'order':\n        target['order'] = target['-webkit-' + key] = isNaN(+value) ? '0' : value;\n        break;\n    }\n  }\n  return target;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/style-utils/style-utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet StyleUtils = /*#__PURE__*/(() => {\n  class StyleUtils {\n    /**\n     * @param {?} _serverStylesheet\n     * @param {?} _serverModuleLoaded\n     * @param {?} _platformId\n     * @param {?} layoutConfig\n     */\n    constructor(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {\n      this._serverStylesheet = _serverStylesheet;\n      this._serverModuleLoaded = _serverModuleLoaded;\n      this._platformId = _platformId;\n      this.layoutConfig = layoutConfig;\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive element\n     * @param {?} element\n     * @param {?} style\n     * @param {?=} value\n     * @return {?}\n     */\n    applyStyleToElement(element, style, value = null) {\n      /** @type {?} */\n      let styles = {};\n      if (typeof style === 'string') {\n        styles[style] = value;\n        style = styles;\n      }\n      styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n      this._applyMultiValueStyleToElement(styles, element);\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive's element\n     * @param {?} style\n     * @param {?=} elements\n     * @return {?}\n     */\n    applyStyleToElements(style, elements = []) {\n      /** @type {?} */\n      const styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n      elements.forEach(\n      /**\n      * @param {?} el\n      * @return {?}\n      */\n      el => {\n        this._applyMultiValueStyleToElement(styles, el);\n      });\n    }\n    /**\n     * Determine the DOM element's Flexbox flow (flex-direction)\n     *\n     * Check inline style first then check computed (stylesheet) style\n     * @param {?} target\n     * @return {?}\n     */\n    getFlowDirection(target) {\n      /** @type {?} */\n      const query = 'flex-direction';\n      /** @type {?} */\n      let value = this.lookupStyle(target, query);\n      /** @type {?} */\n      const hasInlineValue = this.lookupInlineStyle(target, query) || isPlatformServer(this._platformId) && this._serverModuleLoaded ? value : '';\n      return [value || 'row', hasInlineValue];\n    }\n    /**\n     * @param {?} target\n     * @return {?}\n     */\n    hasWrap(target) {\n      /** @type {?} */\n      const query = 'flex-wrap';\n      return this.lookupStyle(target, query) === 'wrap';\n    }\n    /**\n     * Find the DOM element's raw attribute value (if any)\n     * @param {?} element\n     * @param {?} attribute\n     * @return {?}\n     */\n    lookupAttributeValue(element, attribute) {\n      return element.getAttribute(attribute) || '';\n    }\n    /**\n     * Find the DOM element's inline style value (if any)\n     * @param {?} element\n     * @param {?} styleName\n     * @return {?}\n     */\n    lookupInlineStyle(element, styleName) {\n      return isPlatformBrowser(this._platformId) ? element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);\n    }\n    /**\n     * Determine the inline or inherited CSS style\n     * NOTE: platform-server has no implementation for getComputedStyle\n     * @param {?} element\n     * @param {?} styleName\n     * @param {?=} inlineOnly\n     * @return {?}\n     */\n    lookupStyle(element, styleName, inlineOnly = false) {\n      /** @type {?} */\n      let value = '';\n      if (element) {\n        /** @type {?} */\n        let immediateValue = value = this.lookupInlineStyle(element, styleName);\n        if (!immediateValue) {\n          if (isPlatformBrowser(this._platformId)) {\n            if (!inlineOnly) {\n              value = getComputedStyle(element).getPropertyValue(styleName);\n            }\n          } else {\n            if (this._serverModuleLoaded) {\n              value = this._serverStylesheet.getStyleForElement(element, styleName);\n            }\n          }\n        }\n      }\n      // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;\n      //       in which case getComputedStyle() should determine a valid value.\n      return value ? value.trim() : '';\n    }\n    /**\n     * Applies the styles to the element. The styles object map may contain an array of values\n     * Each value will be added as element style\n     * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones\n     * @private\n     * @param {?} styles\n     * @param {?} element\n     * @return {?}\n     */\n    _applyMultiValueStyleToElement(styles, element) {\n      Object.keys(styles).sort().forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        /** @type {?} */\n        const el = styles[key];\n        /** @type {?} */\n        const values = Array.isArray(el) ? el : [el];\n        values.sort();\n        for (let value of values) {\n          value = value ? value + '' : '';\n          if (isPlatformBrowser(this._platformId) || !this._serverModuleLoaded) {\n            isPlatformBrowser(this._platformId) ? element.style.setProperty(key, value) : this._setServerStyle(element, key, value);\n          } else {\n            this._serverStylesheet.addStyleToElement(element, key, value);\n          }\n        }\n      });\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styleName\n     * @param {?=} styleValue\n     * @return {?}\n     */\n    _setServerStyle(element, styleName, styleValue) {\n      styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n      /** @type {?} */\n      const styleMap = this._readStyleAttribute(element);\n      styleMap[styleName] = styleValue || '';\n      this._writeStyleAttribute(element, styleMap);\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styleName\n     * @return {?}\n     */\n    _getServerStyle(element, styleName) {\n      /** @type {?} */\n      const styleMap = this._readStyleAttribute(element);\n      return styleMap[styleName] || '';\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _readStyleAttribute(element) {\n      /** @type {?} */\n      const styleMap = {};\n      /** @type {?} */\n      const styleAttribute = element.getAttribute('style');\n      if (styleAttribute) {\n        /** @type {?} */\n        const styleList = styleAttribute.split(/;+/g);\n        for (let i = 0; i < styleList.length; i++) {\n          /** @type {?} */\n          const style = styleList[i].trim();\n          if (style.length > 0) {\n            /** @type {?} */\n            const colonIndex = style.indexOf(':');\n            if (colonIndex === -1) {\n              throw new Error(`Invalid CSS style: ${style}`);\n            }\n            /** @type {?} */\n            const name = style.substr(0, colonIndex).trim();\n            styleMap[name] = style.substr(colonIndex + 1).trim();\n          }\n        }\n      }\n      return styleMap;\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styleMap\n     * @return {?}\n     */\n    _writeStyleAttribute(element, styleMap) {\n      /** @type {?} */\n      let styleAttrValue = '';\n      for (const key in styleMap) {\n        /** @type {?} */\n        const newValue = styleMap[key];\n        if (newValue) {\n          styleAttrValue += key + ':' + styleMap[key] + ';';\n        }\n      }\n      element.setAttribute('style', styleAttrValue);\n    }\n  }\n  /** @nocollapse */StyleUtils.ɵprov = ɵɵdefineInjectable({\n    factory: function StyleUtils_Factory() {\n      return new StyleUtils(ɵɵinject(StylesheetMap), ɵɵinject(SERVER_TOKEN), ɵɵinject(PLATFORM_ID), ɵɵinject(LAYOUT_CONFIG));\n    },\n    token: StyleUtils,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return StyleUtils;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/style-builder/style-builder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A class that encapsulates CSS style generation for common directives\n * @abstract\n */\nclass StyleBuilder {\n  constructor() {\n    /**\n     * Whether to cache the generated output styles\n     */\n    this.shouldCache = true;\n  }\n  /**\n   * Run a side effect computation given the input string and the computed styles\n   * from the build task and the host configuration object\n   * NOTE: This should be a no-op unless an algorithm is provided in a subclass\n   * @param {?} _input\n   * @param {?} _styles\n   * @param {?=} _parent\n   * @return {?}\n   */\n  sideEffect(_input, _styles, _parent) {}\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/basis-validator/basis-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The flex API permits 3 or 1 parts of the value:\n *    - `flex-grow flex-shrink flex-basis`, or\n *    - `flex-basis`\n * @param {?} basis\n * @param {?=} grow\n * @param {?=} shrink\n * @return {?}\n */\nfunction validateBasis(basis, grow = '1', shrink = '1') {\n  /** @type {?} */\n  let parts = [grow, shrink, basis];\n  /** @type {?} */\n  let j = basis.indexOf('calc');\n  if (j > 0) {\n    parts[2] = _validateCalcValue(basis.substring(j).trim());\n    /** @type {?} */\n    let matches = basis.substr(0, j).trim().split(' ');\n    if (matches.length == 2) {\n      parts[0] = matches[0];\n      parts[1] = matches[1];\n    }\n  } else if (j == 0) {\n    parts[2] = _validateCalcValue(basis.trim());\n  } else {\n    /** @type {?} */\n    let matches = basis.split(' ');\n    parts = matches.length === 3 ? matches : [grow, shrink, basis];\n  }\n  return parts;\n}\n/**\n * Calc expressions require whitespace before & after any expression operators\n * This is a simple, crude whitespace padding solution.\n *   - '3 3 calc(15em + 20px)'\n *   - calc(100% / 7 * 2)\n *   - 'calc(15em + 20px)'\n *   - 'calc(15em+20px)'\n *   - '37px'\n *   = '43%'\n * @param {?} calc\n * @return {?}\n */\nfunction _validateCalcValue(calc) {\n  return calc.replace(/[\\s]/g, '').replace(/[\\/\\*\\+\\-]/g, ' $& ');\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-marshaller/media-marshaller.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * MediaMarshaller - register responsive values from directives and\n *                   trigger them based on media query events\n */\nlet MediaMarshaller = /*#__PURE__*/(() => {\n  class MediaMarshaller {\n    /**\n     * @param {?} matchMedia\n     * @param {?} breakpoints\n     * @param {?} hook\n     */\n    constructor(matchMedia, breakpoints, hook) {\n      this.matchMedia = matchMedia;\n      this.breakpoints = breakpoints;\n      this.hook = hook;\n      this.activatedBreakpoints = [];\n      this.elementMap = new Map();\n      this.elementKeyMap = new WeakMap();\n      this.watcherMap = new WeakMap(); // special triggers to update elements\n      // special triggers to update elements\n      this.updateMap = new WeakMap(); // callback functions to update styles\n      // callback functions to update styles\n      this.clearMap = new WeakMap(); // callback functions to clear styles\n      // callback functions to clear styles\n      this.subject = new Subject();\n      this.observeActivations();\n    }\n    /**\n     * @return {?}\n     */\n    get activatedAlias() {\n      return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : '';\n    }\n    /**\n     * Update styles on breakpoint activates or deactivates\n     * @param {?} mc\n     * @return {?}\n     */\n    onMediaChange(mc) {\n      /** @type {?} */\n      const bp = this.findByQuery(mc.mediaQuery);\n      if (bp) {\n        mc = mergeAlias(mc, bp);\n        if (mc.matches && this.activatedBreakpoints.indexOf(bp) === -1) {\n          this.activatedBreakpoints.push(bp);\n          this.activatedBreakpoints.sort(sortDescendingPriority);\n          this.updateStyles();\n        } else if (!mc.matches && this.activatedBreakpoints.indexOf(bp) !== -1) {\n          // Remove the breakpoint when it's deactivated\n          this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(bp), 1);\n          this.activatedBreakpoints.sort(sortDescendingPriority);\n          this.updateStyles();\n        }\n      }\n    }\n    /**\n     * initialize the marshaller with necessary elements for delegation on an element\n     * @param {?} element\n     * @param {?} key\n     * @param {?=} updateFn optional callback so that custom bp directives don't have to re-provide this\n     * @param {?=} clearFn optional callback so that custom bp directives don't have to re-provide this\n     * @param {?=} extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)\n     * @return {?}\n     */\n    init(element, key, updateFn, clearFn, extraTriggers = []) {\n      initBuilderMap(this.updateMap, element, key, updateFn);\n      initBuilderMap(this.clearMap, element, key, clearFn);\n      this.buildElementKeyMap(element, key);\n      this.watchExtraTriggers(element, key, extraTriggers);\n    }\n    /**\n     * get the value for an element and key and optionally a given breakpoint\n     * @param {?} element\n     * @param {?} key\n     * @param {?=} bp\n     * @return {?}\n     */\n    getValue(element, key, bp) {\n      /** @type {?} */\n      const bpMap = this.elementMap.get(element);\n      if (bpMap) {\n        /** @type {?} */\n        const values = bp !== undefined ? bpMap.get(bp) : this.getActivatedValues(bpMap, key);\n        if (values) {\n          return values.get(key);\n        }\n      }\n      return undefined;\n    }\n    /**\n     * whether the element has values for a given key\n     * @param {?} element\n     * @param {?} key\n     * @return {?}\n     */\n    hasValue(element, key) {\n      /** @type {?} */\n      const bpMap = this.elementMap.get(element);\n      if (bpMap) {\n        /** @type {?} */\n        const values = this.getActivatedValues(bpMap, key);\n        if (values) {\n          return values.get(key) !== undefined || false;\n        }\n      }\n      return false;\n    }\n    /**\n     * Set the value for an input on a directive\n     * @param {?} element the element in question\n     * @param {?} key the type of the directive (e.g. flex, layout-gap, etc)\n     * @param {?} val the value for the breakpoint\n     * @param {?} bp the breakpoint suffix (empty string = default)\n     * @return {?}\n     */\n    setValue(element, key, val, bp) {\n      /** @type {?} */\n      let bpMap = this.elementMap.get(element);\n      if (!bpMap) {\n        bpMap = new Map().set(bp, new Map().set(key, val));\n        this.elementMap.set(element, bpMap);\n      } else {\n        /** @type {?} */\n        const values = (bpMap.get(bp) || new Map()).set(key, val);\n        bpMap.set(bp, values);\n        this.elementMap.set(element, bpMap);\n      }\n      /** @type {?} */\n      const value = this.getValue(element, key);\n      if (value !== undefined) {\n        this.updateElement(element, key, value);\n      }\n    }\n    /**\n     * Track element value changes for a specific key\n     * @param {?} element\n     * @param {?} key\n     * @return {?}\n     */\n    trackValue(element, key) {\n      return this.subject.asObservable().pipe(filter(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      v => v.element === element && v.key === key));\n    }\n    /**\n     * update all styles for all elements on the current breakpoint\n     * @return {?}\n     */\n    updateStyles() {\n      this.elementMap.forEach(\n      /**\n      * @param {?} bpMap\n      * @param {?} el\n      * @return {?}\n      */\n      (bpMap, el) => {\n        /** @type {?} */\n        const keyMap = new Set( /** @type {?} */this.elementKeyMap.get(el));\n        /** @type {?} */\n        let valueMap = this.getActivatedValues(bpMap);\n        if (valueMap) {\n          valueMap.forEach(\n          /**\n          * @param {?} v\n          * @param {?} k\n          * @return {?}\n          */\n          (v, k) => {\n            this.updateElement(el, k, v);\n            keyMap.delete(k);\n          });\n        }\n        keyMap.forEach(\n        /**\n        * @param {?} k\n        * @return {?}\n        */\n        k => {\n          valueMap = this.getActivatedValues(bpMap, k);\n          if (valueMap) {\n            /** @type {?} */\n            const value = valueMap.get(k);\n            this.updateElement(el, k, value);\n          } else {\n            this.clearElement(el, k);\n          }\n        });\n      });\n    }\n    /**\n     * clear the styles for a given element\n     * @param {?} element\n     * @param {?} key\n     * @return {?}\n     */\n    clearElement(element, key) {\n      /** @type {?} */\n      const builders = this.clearMap.get(element);\n      if (builders) {\n        /** @type {?} */\n        const clearFn = /** @type {?} */builders.get(key);\n        if (!!clearFn) {\n          clearFn();\n          this.subject.next({\n            element,\n            key,\n            value: ''\n          });\n        }\n      }\n    }\n    /**\n     * update a given element with the activated values for a given key\n     * @param {?} element\n     * @param {?} key\n     * @param {?} value\n     * @return {?}\n     */\n    updateElement(element, key, value) {\n      /** @type {?} */\n      const builders = this.updateMap.get(element);\n      if (builders) {\n        /** @type {?} */\n        const updateFn = /** @type {?} */builders.get(key);\n        if (!!updateFn) {\n          updateFn(value);\n          this.subject.next({\n            element,\n            key,\n            value\n          });\n        }\n      }\n    }\n    /**\n     * release all references to a given element\n     * @param {?} element\n     * @return {?}\n     */\n    releaseElement(element) {\n      /** @type {?} */\n      const watcherMap = this.watcherMap.get(element);\n      if (watcherMap) {\n        watcherMap.forEach(\n        /**\n        * @param {?} s\n        * @return {?}\n        */\n        s => s.unsubscribe());\n        this.watcherMap.delete(element);\n      }\n      /** @type {?} */\n      const elementMap = this.elementMap.get(element);\n      if (elementMap) {\n        elementMap.forEach(\n        /**\n        * @param {?} _\n        * @param {?} s\n        * @return {?}\n        */\n        (_, s) => elementMap.delete(s));\n        this.elementMap.delete(element);\n      }\n    }\n    /**\n     * trigger an update for a given element and key (e.g. layout)\n     * @param {?} element\n     * @param {?=} key\n     * @return {?}\n     */\n    triggerUpdate(element, key) {\n      /** @type {?} */\n      const bpMap = this.elementMap.get(element);\n      if (bpMap) {\n        /** @type {?} */\n        const valueMap = this.getActivatedValues(bpMap, key);\n        if (valueMap) {\n          if (key) {\n            this.updateElement(element, key, valueMap.get(key));\n          } else {\n            valueMap.forEach(\n            /**\n            * @param {?} v\n            * @param {?} k\n            * @return {?}\n            */\n            (v, k) => this.updateElement(element, k, v));\n          }\n        }\n      }\n    }\n    /**\n     * Cross-reference for HTMLElement with directive key\n     * @private\n     * @param {?} element\n     * @param {?} key\n     * @return {?}\n     */\n    buildElementKeyMap(element, key) {\n      /** @type {?} */\n      let keyMap = this.elementKeyMap.get(element);\n      if (!keyMap) {\n        keyMap = new Set();\n        this.elementKeyMap.set(element, keyMap);\n      }\n      keyMap.add(key);\n    }\n    /**\n     * Other triggers that should force style updates:\n     * - directionality\n     * - layout changes\n     * - mutationobserver updates\n     * @private\n     * @param {?} element\n     * @param {?} key\n     * @param {?} triggers\n     * @return {?}\n     */\n    watchExtraTriggers(element, key, triggers) {\n      if (triggers && triggers.length) {\n        /** @type {?} */\n        let watchers = this.watcherMap.get(element);\n        if (!watchers) {\n          watchers = new Map();\n          this.watcherMap.set(element, watchers);\n        }\n        /** @type {?} */\n        const subscription = watchers.get(key);\n        if (!subscription) {\n          /** @type {?} */\n          const newSubscription = merge(...triggers).subscribe(\n          /**\n          * @return {?}\n          */\n          () => {\n            /** @type {?} */\n            const currentValue = this.getValue(element, key);\n            this.updateElement(element, key, currentValue);\n          });\n          watchers.set(key, newSubscription);\n        }\n      }\n    }\n    /**\n     * Breakpoint locator by mediaQuery\n     * @private\n     * @param {?} query\n     * @return {?}\n     */\n    findByQuery(query) {\n      return this.breakpoints.findByQuery(query);\n    }\n    /**\n     * get the fallback breakpoint for a given element, starting with the current breakpoint\n     * @private\n     * @param {?} bpMap\n     * @param {?=} key\n     * @return {?}\n     */\n    getActivatedValues(bpMap, key) {\n      for (let i = 0; i < this.activatedBreakpoints.length; i++) {\n        /** @type {?} */\n        const activatedBp = this.activatedBreakpoints[i];\n        /** @type {?} */\n        const valueMap = bpMap.get(activatedBp.alias);\n        if (valueMap) {\n          if (key === undefined || valueMap.has(key) && valueMap.get(key) != null) {\n            return valueMap;\n          }\n        }\n      }\n      /** @type {?} */\n      const lastHope = bpMap.get('');\n      return key === undefined || lastHope && lastHope.has(key) ? lastHope : undefined;\n    }\n    /**\n     * Watch for mediaQuery breakpoint activations\n     * @private\n     * @return {?}\n     */\n    observeActivations() {\n      /** @type {?} */\n      const target = /** @type {?} */ /** @type {?} */this;\n      /** @type {?} */\n      const queries = this.breakpoints.items.map(\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n      bp => bp.mediaQuery);\n      this.matchMedia.observe(this.hook.withPrintQuery(queries)).pipe(tap(this.hook.interceptEvents(target)), filter(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this));\n    }\n  }\n  /** @nocollapse */MediaMarshaller.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaMarshaller_Factory() {\n      return new MediaMarshaller(ɵɵinject(MatchMedia), ɵɵinject(BreakPointRegistry), ɵɵinject(PrintHook));\n    },\n    token: MediaMarshaller,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return MediaMarshaller;\n})();\n/**\n * @param {?} map\n * @param {?} element\n * @param {?} key\n * @param {?=} input\n * @return {?}\n */\nfunction initBuilderMap(map$$1, element, key, input) {\n  if (input !== undefined) {\n    /** @type {?} */\n    let oldMap = map$$1.get(element);\n    if (!oldMap) {\n      oldMap = new Map();\n      map$$1.set(element, oldMap);\n    }\n    oldMap.set(key, input);\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MatchMedia as ɵMatchMedia, MockMatchMedia as ɵMockMatchMedia, MockMatchMediaProvider as ɵMockMatchMediaProvider, CoreModule, removeStyles, BROWSER_PROVIDER, CLASS_NAME, MediaChange, StylesheetMap, DEFAULT_CONFIG, LAYOUT_CONFIG, SERVER_TOKEN, BREAKPOINT, mergeAlias, BaseDirective2, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BreakPointRegistry, BREAKPOINTS, MediaObserver, MediaTrigger, sortDescendingPriority, sortAscendingPriority, coerceArray, StyleUtils, StyleBuilder, validateBasis, MediaMarshaller, BREAKPOINT_PRINT, PrintHook };\n//# sourceMappingURL=core.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}