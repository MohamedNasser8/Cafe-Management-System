{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Inject, Input, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { BaseDirective2, StyleBuilder, StyleUtils, MediaMarshaller, CoreModule, LAYOUT_CONFIG, validateBasis } from '@angular/flex-layout/core';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/layout-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @type {?}\n */\nconst INLINE = 'inline';\n/** @type {?} */\nconst LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\nfunction buildLayoutCSS(value) {\n  let [direction, wrap, isInline] = validateValue(value);\n  return buildCSS(direction, wrap, isInline);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\nfunction validateValue(value) {\n  value = value ? value.toLowerCase() : '';\n  let [direction, wrap, inline] = value.split(' ');\n  // First value must be the `flex-direction`\n  if (!LAYOUT_VALUES.find(\n  /**\n  * @param {?} x\n  * @return {?}\n  */\n  x => x === direction)) {\n    direction = LAYOUT_VALUES[0];\n  }\n  if (wrap === INLINE) {\n    wrap = inline !== INLINE ? inline : '';\n    inline = INLINE;\n  }\n  return [direction, validateWrapValue(wrap), !!inline];\n}\n/**\n * Determine if the validated, flex-direction value specifies\n * a horizontal/row flow.\n * @param {?} value\n * @return {?}\n */\nfunction isFlowHorizontal(value) {\n  let [flow] = validateValue(value);\n  return flow.indexOf('row') > -1;\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\nfunction validateWrapValue(value) {\n  if (!!value) {\n    switch (value.toLowerCase()) {\n      case 'reverse':\n      case 'wrap-reverse':\n      case 'reverse-wrap':\n        value = 'wrap-reverse';\n        break;\n      case 'no':\n      case 'none':\n      case 'nowrap':\n        value = 'nowrap';\n        break;\n      // All other values fallback to 'wrap'\n      default:\n        value = 'wrap';\n        break;\n    }\n  }\n  return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @param {?=} inline\n * @return {?}\n */\nfunction buildCSS(direction, wrap = null, inline = false) {\n  return {\n    'display': inline ? 'inline-flex' : 'flex',\n    'box-sizing': 'border-box',\n    'flex-direction': direction,\n    'flex-wrap': !!wrap ? wrap : null\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/layout/layout.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet LayoutStyleBuilder = /*#__PURE__*/(() => {\n  class LayoutStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    buildStyles(input) {\n      return buildLayoutCSS(input);\n    }\n  }\n  /** @nocollapse */LayoutStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function LayoutStyleBuilder_Factory() {\n      return new LayoutStyleBuilder();\n    },\n    token: LayoutStyleBuilder,\n    providedIn: \"root\"\n  });\n  return LayoutStyleBuilder;\n})();\n/** @type {?} */\nconst inputs = ['fxLayout', 'fxLayout.xs', 'fxLayout.sm', 'fxLayout.md', 'fxLayout.lg', 'fxLayout.xl', 'fxLayout.lt-sm', 'fxLayout.lt-md', 'fxLayout.lt-lg', 'fxLayout.lt-xl', 'fxLayout.gt-xs', 'fxLayout.gt-sm', 'fxLayout.gt-md', 'fxLayout.gt-lg'];\n/** @type {?} */\nconst selector = `\n  [fxLayout], [fxLayout.xs], [fxLayout.sm], [fxLayout.md],\n  [fxLayout.lg], [fxLayout.xl], [fxLayout.lt-sm], [fxLayout.lt-md],\n  [fxLayout.lt-lg], [fxLayout.lt-xl], [fxLayout.gt-xs], [fxLayout.gt-sm],\n  [fxLayout.gt-md], [fxLayout.gt-lg]\n`;\n/**\n * 'layout' flexbox styling directive\n * Defines the positioning flow direction for the child elements: row or column\n * Optional values: column or row (default)\n * @see https://css-tricks.com/almanac/properties/f/flex-direction/\n *\n */\nclass LayoutDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.DIRECTIVE_KEY = 'layout';\n    this.styleCache = layoutCache;\n    this.init();\n  }\n}\n\n/** @nocollapse */\n\nclass DefaultLayoutDirective extends LayoutDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs;\n  }\n}\n/** @type {?} */\nconst layoutCache = /*#__PURE__*/new Map();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/layout-gap/layout-gap.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CLEAR_MARGIN_CSS = {\n  'margin-left': null,\n  'margin-right': null,\n  'margin-top': null,\n  'margin-bottom': null\n};\nlet LayoutGapStyleBuilder = /*#__PURE__*/(() => {\n  class LayoutGapStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} _styler\n     */\n    constructor(_styler) {\n      super();\n      this._styler = _styler;\n    }\n    /**\n     * @param {?} gapValue\n     * @param {?} parent\n     * @return {?}\n     */\n    buildStyles(gapValue, parent) {\n      if (gapValue.endsWith(GRID_SPECIFIER)) {\n        gapValue = gapValue.slice(0, gapValue.indexOf(GRID_SPECIFIER));\n        // Add the margin to the host element\n        return buildGridMargin(gapValue, parent.directionality);\n      } else {\n        return {};\n      }\n    }\n    /**\n     * @param {?} gapValue\n     * @param {?} _styles\n     * @param {?} parent\n     * @return {?}\n     */\n    sideEffect(gapValue, _styles, parent) {\n      /** @type {?} */\n      const items = parent.items;\n      if (gapValue.endsWith(GRID_SPECIFIER)) {\n        gapValue = gapValue.slice(0, gapValue.indexOf(GRID_SPECIFIER));\n        // For each `element` children, set the padding\n        /** @type {?} */\n        const paddingStyles = buildGridPadding(gapValue, parent.directionality);\n        this._styler.applyStyleToElements(paddingStyles, parent.items);\n      } else {\n        /** @type {?} */\n        const lastItem = /** @type {?} */items.pop();\n        // For each `element` children EXCEPT the last,\n        // set the margin right/bottom styles...\n        /** @type {?} */\n        const gapCss = buildGapCSS(gapValue, parent);\n        this._styler.applyStyleToElements(gapCss, items);\n        // Clear all gaps for all visible elements\n        this._styler.applyStyleToElements(CLEAR_MARGIN_CSS, [lastItem]);\n      }\n    }\n  }\n  /** @nocollapse */LayoutGapStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function LayoutGapStyleBuilder_Factory() {\n      return new LayoutGapStyleBuilder(ɵɵinject(StyleUtils));\n    },\n    token: LayoutGapStyleBuilder,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return LayoutGapStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$1 = ['fxLayoutGap', 'fxLayoutGap.xs', 'fxLayoutGap.sm', 'fxLayoutGap.md', 'fxLayoutGap.lg', 'fxLayoutGap.xl', 'fxLayoutGap.lt-sm', 'fxLayoutGap.lt-md', 'fxLayoutGap.lt-lg', 'fxLayoutGap.lt-xl', 'fxLayoutGap.gt-xs', 'fxLayoutGap.gt-sm', 'fxLayoutGap.gt-md', 'fxLayoutGap.gt-lg'];\n/** @type {?} */\nconst selector$1 = `\n  [fxLayoutGap], [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md],\n  [fxLayoutGap.lg], [fxLayoutGap.xl], [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md],\n  [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl], [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm],\n  [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\n`;\n/**\n * 'layout-padding' styling directive\n *  Defines padding of child elements in a layout container\n */\nclass LayoutGapDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} zone\n   * @param {?} directionality\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, zone, directionality, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.zone = zone;\n    this.directionality = directionality;\n    this.styleUtils = styleUtils;\n    this.layout = 'row'; // default flex-direction\n    // default flex-direction\n    this.DIRECTIVE_KEY = 'layout-gap';\n    this.observerSubject = new Subject();\n    /** @type {?} */\n    const extraTriggers = [this.directionality.change, this.observerSubject.asObservable()];\n    this.init(extraTriggers);\n    this.marshal.trackValue(this.nativeElement, 'layout').pipe(takeUntil(this.destroySubject)).subscribe(this.onLayoutChange.bind(this));\n  }\n  /**\n   * Special accessor to query for all child 'element' nodes regardless of type, class, etc\n   * @protected\n   * @return {?}\n   */\n  get childrenNodes() {\n    /** @type {?} */\n    const obj = this.nativeElement.children;\n    /** @type {?} */\n    const buffer = [];\n    // iterate backwards ensuring that length is an UInt32\n    for (let i = obj.length; i--;) {\n      buffer[i] = obj[i];\n    }\n    return buffer;\n  }\n  // *********************************************\n  // Lifecycle Methods\n  // *********************************************\n  /**\n   * @return {?}\n   */\n  ngAfterContentInit() {\n    this.buildChildObservable();\n    this.triggerUpdate();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n  }\n  // *********************************************\n  // Protected methods\n  // *********************************************\n  /**\n   * Cache the parent container 'flex-direction' and update the 'margin' styles\n   * @protected\n   * @param {?} matcher\n   * @return {?}\n   */\n  onLayoutChange(matcher) {\n    /** @type {?} */\n    const layout = matcher.value;\n    // Make sure to filter out 'wrap' option\n    /** @type {?} */\n    const direction = layout.split(' ');\n    this.layout = direction[0];\n    if (!LAYOUT_VALUES.find(\n    /**\n    * @param {?} x\n    * @return {?}\n    */\n    x => x === this.layout)) {\n      this.layout = 'row';\n    }\n    this.triggerUpdate();\n  }\n  /**\n   *\n   * @protected\n   * @param {?} value\n   * @return {?}\n   */\n  updateWithValue(value) {\n    // Gather all non-hidden Element nodes\n    /** @type {?} */\n    const items = this.childrenNodes.filter(\n    /**\n    * @param {?} el\n    * @return {?}\n    */\n    el => el.nodeType === 1 && this.willDisplay(el)).sort(\n    /**\n    * @param {?} a\n    * @param {?} b\n    * @return {?}\n    */\n    (a, b) => {\n      /** @type {?} */\n      const orderA = +this.styler.lookupStyle(a, 'order');\n      /** @type {?} */\n      const orderB = +this.styler.lookupStyle(b, 'order');\n      if (isNaN(orderA) || isNaN(orderB) || orderA === orderB) {\n        return 0;\n      } else {\n        return orderA > orderB ? 1 : -1;\n      }\n    });\n    if (items.length > 0) {\n      /** @type {?} */\n      const directionality = this.directionality.value;\n      /** @type {?} */\n      const layout = this.layout;\n      if (layout === 'row' && directionality === 'rtl') {\n        this.styleCache = layoutGapCacheRowRtl;\n      } else if (layout === 'row' && directionality !== 'rtl') {\n        this.styleCache = layoutGapCacheRowLtr;\n      } else if (layout === 'column' && directionality === 'rtl') {\n        this.styleCache = layoutGapCacheColumnRtl;\n      } else if (layout === 'column' && directionality !== 'rtl') {\n        this.styleCache = layoutGapCacheColumnLtr;\n      }\n      this.addStyles(value, {\n        directionality,\n        items,\n        layout\n      });\n    }\n  }\n  /**\n   * We need to override clearStyles because in most cases mru isn't populated\n   * @protected\n   * @return {?}\n   */\n  clearStyles() {\n    /** @type {?} */\n    const gridMode = Object.keys(this.mru).length > 0;\n    /** @type {?} */\n    const childrenStyle = gridMode ? 'padding' : getMarginType(this.directionality.value, this.layout);\n    // If there are styles on the parent remove them\n    if (gridMode) {\n      super.clearStyles();\n    }\n    // Then remove the children styles too\n    this.styleUtils.applyStyleToElements({\n      [childrenStyle]: ''\n    }, this.childrenNodes);\n  }\n  /**\n   * Determine if an element will show or hide based on current activation\n   * @protected\n   * @param {?} source\n   * @return {?}\n   */\n  willDisplay(source) {\n    /** @type {?} */\n    const value = this.marshal.getValue(source, 'show-hide');\n    return value === true || value === undefined && this.styleUtils.lookupStyle(source, 'display') !== 'none';\n  }\n  /**\n   * @protected\n   * @return {?}\n   */\n  buildChildObservable() {\n    this.zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (typeof MutationObserver !== 'undefined') {\n        this.observer = new MutationObserver(\n        /**\n        * @param {?} mutations\n        * @return {?}\n        */\n        mutations => {\n          /** @type {?} */\n          const validatedChanges =\n          /**\n          * @param {?} it\n          * @return {?}\n          */\n          it => {\n            return it.addedNodes && it.addedNodes.length > 0 || it.removedNodes && it.removedNodes.length > 0;\n          };\n          // update gap styles only for child 'added' or 'removed' events\n          if (mutations.some(validatedChanges)) {\n            this.observerSubject.next();\n          }\n        });\n        this.observer.observe(this.nativeElement, {\n          childList: true\n        });\n      }\n    });\n  }\n}\n\n/** @nocollapse */\n\nclass DefaultLayoutGapDirective extends LayoutGapDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$1;\n  }\n}\n/** @type {?} */\nconst layoutGapCacheRowRtl = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutGapCacheColumnRtl = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutGapCacheRowLtr = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutGapCacheColumnLtr = /*#__PURE__*/new Map();\n/** @type {?} */\nconst GRID_SPECIFIER = ' grid';\n/**\n * @param {?} value\n * @param {?} directionality\n * @return {?}\n */\nfunction buildGridPadding(value, directionality) {\n  const [between, below] = value.split(' ');\n  /** @type {?} */\n  const bottom = below || between;\n  /** @type {?} */\n  let paddingRight = '0px';\n  /** @type {?} */\n  let paddingBottom = bottom;\n  /** @type {?} */\n  let paddingLeft = '0px';\n  if (directionality === 'rtl') {\n    paddingLeft = between;\n  } else {\n    paddingRight = between;\n  }\n  return {\n    'padding': `0px ${paddingRight} ${paddingBottom} ${paddingLeft}`\n  };\n}\n/**\n * @param {?} value\n * @param {?} directionality\n * @return {?}\n */\nfunction buildGridMargin(value, directionality) {\n  const [between, below] = value.split(' ');\n  /** @type {?} */\n  const bottom = below || between;\n  /** @type {?} */\n  const minus =\n  /**\n  * @param {?} str\n  * @return {?}\n  */\n  str => `-${str}`;\n  /** @type {?} */\n  let marginRight = '0px';\n  /** @type {?} */\n  let marginBottom = minus(bottom);\n  /** @type {?} */\n  let marginLeft = '0px';\n  if (directionality === 'rtl') {\n    marginLeft = minus(between);\n  } else {\n    marginRight = minus(between);\n  }\n  return {\n    'margin': `0px ${marginRight} ${marginBottom} ${marginLeft}`\n  };\n}\n/**\n * @param {?} directionality\n * @param {?} layout\n * @return {?}\n */\nfunction getMarginType(directionality, layout) {\n  switch (layout) {\n    case 'column':\n      return 'margin-bottom';\n    case 'column-reverse':\n      return 'margin-top';\n    case 'row':\n      return directionality === 'rtl' ? 'margin-left' : 'margin-right';\n    case 'row-reverse':\n      return directionality === 'rtl' ? 'margin-right' : 'margin-left';\n    default:\n      return directionality === 'rtl' ? 'margin-left' : 'margin-right';\n  }\n}\n/**\n * @param {?} gapValue\n * @param {?} parent\n * @return {?}\n */\nfunction buildGapCSS(gapValue, parent) {\n  /** @type {?} */\n  const key = getMarginType(parent.directionality, parent.layout);\n  /** @type {?} */\n  const margins = Object.assign({}, CLEAR_MARGIN_CSS);\n  margins[key] = gapValue;\n  return margins;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/object-extend.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n  if (dest == null) {\n    throw TypeError('Cannot convert undefined or null to object');\n  }\n  for (let source of sources) {\n    if (source != null) {\n      for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = source[key];\n        }\n      }\n    }\n  }\n  return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/flex/flex.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FlexStyleBuilder = /*#__PURE__*/(() => {\n  class FlexStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} layoutConfig\n     */\n    constructor(layoutConfig) {\n      super();\n      this.layoutConfig = layoutConfig;\n    }\n    /**\n     * @param {?} input\n     * @param {?} parent\n     * @return {?}\n     */\n    buildStyles(input, parent) {\n      let [grow, shrink, ...basisParts] = input.split(' ');\n      /** @type {?} */\n      let basis = basisParts.join(' ');\n      // The flex-direction of this element's flex container. Defaults to 'row'.\n      /** @type {?} */\n      const direction = parent.direction.indexOf('column') > -1 ? 'column' : 'row';\n      /** @type {?} */\n      const max = isFlowHorizontal(direction) ? 'max-width' : 'max-height';\n      /** @type {?} */\n      const min = isFlowHorizontal(direction) ? 'min-width' : 'min-height';\n      /** @type {?} */\n      const hasCalc = String(basis).indexOf('calc') > -1;\n      /** @type {?} */\n      const usingCalc = hasCalc || basis === 'auto';\n      /** @type {?} */\n      const isPercent = String(basis).indexOf('%') > -1 && !hasCalc;\n      /** @type {?} */\n      const hasUnits = String(basis).indexOf('px') > -1 || String(basis).indexOf('rem') > -1 || String(basis).indexOf('em') > -1 || String(basis).indexOf('vw') > -1 || String(basis).indexOf('vh') > -1;\n      /** @type {?} */\n      let isValue = hasCalc || hasUnits;\n      grow = grow == '0' ? 0 : grow;\n      shrink = shrink == '0' ? 0 : shrink;\n      // make box inflexible when shrink and grow are both zero\n      // should not set a min when the grow is zero\n      // should not set a max when the shrink is zero\n      /** @type {?} */\n      const isFixed = !grow && !shrink;\n      /** @type {?} */\n      let css = {};\n      // flex-basis allows you to specify the initial/starting main-axis size of the element,\n      // before anything else is computed. It can either be a percentage or an absolute value.\n      // It is, however, not the breaking point for flex-grow/shrink properties\n      //\n      // flex-grow can be seen as this:\n      //   0: Do not stretch. Either size to element's content width, or obey 'flex-basis'.\n      //   1: (Default value). Stretch; will be the same size to all other flex items on\n      //       the same row since they have a default value of 1.\n      //   ≥2 (integer n): Stretch. Will be n times the size of other elements\n      //      with 'flex-grow: 1' on the same row.\n      // Use `null` to clear existing styles.\n      /** @type {?} */\n      const clearStyles = {\n        'max-width': null,\n        'max-height': null,\n        'min-width': null,\n        'min-height': null\n      };\n      switch (basis || '') {\n        case '':\n          /** @type {?} */\n          const useColumnBasisZero = this.layoutConfig.useColumnBasisZero !== false;\n          basis = direction === 'row' ? '0%' : useColumnBasisZero ? '0.000000001px' : 'auto';\n          break;\n        case 'initial': // default\n        case 'nogrow':\n          grow = 0;\n          basis = 'auto';\n          break;\n        case 'grow':\n          basis = '100%';\n          break;\n        case 'noshrink':\n          shrink = 0;\n          basis = 'auto';\n          break;\n        case 'auto':\n          break;\n        case 'none':\n          grow = 0;\n          shrink = 0;\n          basis = 'auto';\n          break;\n        default:\n          // Defaults to percentage sizing unless `px` is explicitly set\n          if (!isValue && !isPercent && !isNaN( /** @type {?} */basis)) {\n            basis = basis + '%';\n          }\n          // Fix for issue 280\n          if (basis === '0%') {\n            isValue = true;\n          }\n          if (basis === '0px') {\n            basis = '0%';\n          }\n          // fix issue #5345\n          if (hasCalc) {\n            css = extendObject(clearStyles, {\n              'flex-grow': grow,\n              'flex-shrink': shrink,\n              'flex-basis': isValue ? basis : '100%'\n            });\n          } else {\n            css = extendObject(clearStyles, {\n              'flex': `${grow} ${shrink} ${isValue ? basis : '100%'}`\n            });\n          }\n          break;\n      }\n      if (!(css['flex'] || css['flex-grow'])) {\n        if (hasCalc) {\n          css = extendObject(clearStyles, {\n            'flex-grow': grow,\n            'flex-shrink': shrink,\n            'flex-basis': basis\n          });\n        } else {\n          css = extendObject(clearStyles, {\n            'flex': `${grow} ${shrink} ${basis}`\n          });\n        }\n      }\n      // Fix for issues 277, 534, and 728\n      if (basis !== '0%' && basis !== '0px' && basis !== '0.000000001px' && basis !== 'auto') {\n        css[min] = isFixed || isValue && grow ? basis : null;\n        css[max] = isFixed || !usingCalc && shrink ? basis : null;\n      }\n      // Fix for issue 528\n      if (!css[min] && !css[max]) {\n        if (hasCalc) {\n          css = extendObject(clearStyles, {\n            'flex-grow': grow,\n            'flex-shrink': shrink,\n            'flex-basis': basis\n          });\n        } else {\n          css = extendObject(clearStyles, {\n            'flex': `${grow} ${shrink} ${basis}`\n          });\n        }\n      } else {\n        // Fix for issue 660\n        if (parent.hasWrap) {\n          css[hasCalc ? 'flex-basis' : 'flex'] = css[max] ? hasCalc ? css[max] : `${grow} ${shrink} ${css[max]}` : hasCalc ? css[min] : `${grow} ${shrink} ${css[min]}`;\n        }\n      }\n      return (/** @type {?} */extendObject(css, {\n          'box-sizing': 'border-box'\n        })\n      );\n    }\n  }\n  /** @nocollapse */FlexStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function FlexStyleBuilder_Factory() {\n      return new FlexStyleBuilder(ɵɵinject(LAYOUT_CONFIG));\n    },\n    token: FlexStyleBuilder,\n    providedIn: \"root\"\n  });\n\n  /** @nocollapse */\n  return FlexStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$2 = ['fxFlex', 'fxFlex.xs', 'fxFlex.sm', 'fxFlex.md', 'fxFlex.lg', 'fxFlex.xl', 'fxFlex.lt-sm', 'fxFlex.lt-md', 'fxFlex.lt-lg', 'fxFlex.lt-xl', 'fxFlex.gt-xs', 'fxFlex.gt-sm', 'fxFlex.gt-md', 'fxFlex.gt-lg'];\n/** @type {?} */\nconst selector$2 = `\n  [fxFlex], [fxFlex.xs], [fxFlex.sm], [fxFlex.md],\n  [fxFlex.lg], [fxFlex.xl], [fxFlex.lt-sm], [fxFlex.lt-md],\n  [fxFlex.lt-lg], [fxFlex.lt-xl], [fxFlex.gt-xs], [fxFlex.gt-sm],\n  [fxFlex.gt-md], [fxFlex.gt-lg]\n`;\n/**\n * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.\n * Corresponds to the css `flex` shorthand property.\n *\n * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/\n */\nclass FlexDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} layoutConfig\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, layoutConfig, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.layoutConfig = layoutConfig;\n    this.marshal = marshal;\n    this.DIRECTIVE_KEY = 'flex';\n    this.direction = undefined;\n    this.wrap = undefined;\n    this.flexGrow = '1';\n    this.flexShrink = '1';\n    this.init();\n  }\n  /**\n   * @return {?}\n   */\n  get shrink() {\n    return this.flexShrink;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set shrink(value) {\n    this.flexShrink = value || '1';\n    this.triggerReflow();\n  }\n  /**\n   * @return {?}\n   */\n  get grow() {\n    return this.flexGrow;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set grow(value) {\n    this.flexGrow = value || '1';\n    this.triggerReflow();\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (this.parentElement) {\n      this.marshal.trackValue(this.parentElement, 'layout').pipe(takeUntil(this.destroySubject)).subscribe(this.onLayoutChange.bind(this));\n      this.marshal.trackValue(this.nativeElement, 'layout-align').pipe(takeUntil(this.destroySubject)).subscribe(this.triggerReflow.bind(this));\n    }\n  }\n  /**\n   * Caches the parent container's 'flex-direction' and updates the element's style.\n   * Used as a handler for layout change events from the parent flex container.\n   * @protected\n   * @param {?} matcher\n   * @return {?}\n   */\n  onLayoutChange(matcher) {\n    /** @type {?} */\n    const layout = matcher.value;\n    /** @type {?} */\n    const layoutParts = layout.split(' ');\n    this.direction = layoutParts[0];\n    this.wrap = layoutParts[1] !== undefined && layoutParts[1] === 'wrap';\n    this.triggerUpdate();\n  }\n  /**\n   * Input to this is exclusively the basis input value\n   * @protected\n   * @param {?} value\n   * @return {?}\n   */\n  updateWithValue(value) {\n    /** @type {?} */\n    const addFlexToParent = this.layoutConfig.addFlexToParent !== false;\n    if (this.direction === undefined) {\n      this.direction = this.getFlexFlowDirection( /** @type {?} */this.parentElement, addFlexToParent);\n    }\n    if (this.wrap === undefined) {\n      this.wrap = this.hasWrap( /** @type {?} */this.parentElement);\n    }\n    /** @type {?} */\n    const direction = this.direction;\n    /** @type {?} */\n    const isHorizontal = direction.startsWith('row');\n    /** @type {?} */\n    const hasWrap = this.wrap;\n    if (isHorizontal && hasWrap) {\n      this.styleCache = flexRowWrapCache;\n    } else if (isHorizontal && !hasWrap) {\n      this.styleCache = flexRowCache;\n    } else if (!isHorizontal && hasWrap) {\n      this.styleCache = flexColumnWrapCache;\n    } else if (!isHorizontal && !hasWrap) {\n      this.styleCache = flexColumnCache;\n    }\n    /** @type {?} */\n    const basis = String(value).replace(';', '');\n    /** @type {?} */\n    const parts = validateBasis(basis, this.flexGrow, this.flexShrink);\n    this.addStyles(parts.join(' '), {\n      direction,\n      hasWrap\n    });\n  }\n  /**\n   * Trigger a style reflow, usually based on a shrink/grow input event\n   * @protected\n   * @return {?}\n   */\n  triggerReflow() {\n    /** @type {?} */\n    const activatedValue = this.activatedValue;\n    if (activatedValue !== undefined) {\n      /** @type {?} */\n      const parts = validateBasis(activatedValue + '', this.flexGrow, this.flexShrink);\n      this.marshal.updateElement(this.nativeElement, this.DIRECTIVE_KEY, parts.join(' '));\n    }\n  }\n}\n\n/** @nocollapse */\n\nclass DefaultFlexDirective extends FlexDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$2;\n  }\n}\n/** @type {?} */\nconst flexRowCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexColumnCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexRowWrapCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexColumnWrapCache = /*#__PURE__*/new Map();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/flex-order/flex-order.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FlexOrderStyleBuilder = /*#__PURE__*/(() => {\n  class FlexOrderStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    buildStyles(value) {\n      return {\n        order: value && parseInt(value, 10) || ''\n      };\n    }\n  }\n  /** @nocollapse */FlexOrderStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function FlexOrderStyleBuilder_Factory() {\n      return new FlexOrderStyleBuilder();\n    },\n    token: FlexOrderStyleBuilder,\n    providedIn: \"root\"\n  });\n  return FlexOrderStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$3 = ['fxFlexOrder', 'fxFlexOrder.xs', 'fxFlexOrder.sm', 'fxFlexOrder.md', 'fxFlexOrder.lg', 'fxFlexOrder.xl', 'fxFlexOrder.lt-sm', 'fxFlexOrder.lt-md', 'fxFlexOrder.lt-lg', 'fxFlexOrder.lt-xl', 'fxFlexOrder.gt-xs', 'fxFlexOrder.gt-sm', 'fxFlexOrder.gt-md', 'fxFlexOrder.gt-lg'];\n/** @type {?} */\nconst selector$3 = `\n  [fxFlexOrder], [fxFlexOrder.xs], [fxFlexOrder.sm], [fxFlexOrder.md],\n  [fxFlexOrder.lg], [fxFlexOrder.xl], [fxFlexOrder.lt-sm], [fxFlexOrder.lt-md],\n  [fxFlexOrder.lt-lg], [fxFlexOrder.lt-xl], [fxFlexOrder.gt-xs], [fxFlexOrder.gt-sm],\n  [fxFlexOrder.gt-md], [fxFlexOrder.gt-lg]\n`;\n/**\n * 'flex-order' flexbox styling directive\n * Configures the positional ordering of the element in a sorted layout container\n * @see https://css-tricks.com/almanac/properties/o/order/\n */\nclass FlexOrderDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.DIRECTIVE_KEY = 'flex-order';\n    this.styleCache = flexOrderCache;\n    this.init();\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst flexOrderCache = /*#__PURE__*/new Map();\nclass DefaultFlexOrderDirective extends FlexOrderDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$3;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/flex-offset/flex-offset.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FlexOffsetStyleBuilder = /*#__PURE__*/(() => {\n  class FlexOffsetStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} offset\n     * @param {?} parent\n     * @return {?}\n     */\n    buildStyles(offset, parent) {\n      if (offset === '') {\n        offset = '0';\n      }\n      /** @type {?} */\n      const isPercent = String(offset).indexOf('%') > -1;\n      /** @type {?} */\n      const isPx = String(offset).indexOf('px') > -1;\n      if (!isPx && !isPercent && !isNaN(+offset)) {\n        offset = offset + '%';\n      }\n      /** @type {?} */\n      const horizontalLayoutKey = parent.isRtl ? 'margin-right' : 'margin-left';\n      /** @type {?} */\n      const styles = isFlowHorizontal(parent.layout) ? {\n        [horizontalLayoutKey]: `${offset}`\n      } : {\n        'margin-top': `${offset}`\n      };\n      return styles;\n    }\n  }\n  /** @nocollapse */FlexOffsetStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function FlexOffsetStyleBuilder_Factory() {\n      return new FlexOffsetStyleBuilder();\n    },\n    token: FlexOffsetStyleBuilder,\n    providedIn: \"root\"\n  });\n  return FlexOffsetStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$4 = ['fxFlexOffset', 'fxFlexOffset.xs', 'fxFlexOffset.sm', 'fxFlexOffset.md', 'fxFlexOffset.lg', 'fxFlexOffset.xl', 'fxFlexOffset.lt-sm', 'fxFlexOffset.lt-md', 'fxFlexOffset.lt-lg', 'fxFlexOffset.lt-xl', 'fxFlexOffset.gt-xs', 'fxFlexOffset.gt-sm', 'fxFlexOffset.gt-md', 'fxFlexOffset.gt-lg'];\n/** @type {?} */\nconst selector$4 = `\n  [fxFlexOffset], [fxFlexOffset.xs], [fxFlexOffset.sm], [fxFlexOffset.md],\n  [fxFlexOffset.lg], [fxFlexOffset.xl], [fxFlexOffset.lt-sm], [fxFlexOffset.lt-md],\n  [fxFlexOffset.lt-lg], [fxFlexOffset.lt-xl], [fxFlexOffset.gt-xs], [fxFlexOffset.gt-sm],\n  [fxFlexOffset.gt-md], [fxFlexOffset.gt-lg]\n`;\n/**\n * 'flex-offset' flexbox styling directive\n * Configures the 'margin-left' of the element in a layout container\n */\nclass FlexOffsetDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} directionality\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   * @param {?} styler\n   */\n  constructor(elRef, directionality, styleBuilder, marshal, styler) {\n    super(elRef, styleBuilder, styler, marshal);\n    this.directionality = directionality;\n    this.DIRECTIVE_KEY = 'flex-offset';\n    this.init([this.directionality.change]);\n    // Parent DOM `layout-gap` with affect the nested child with `flex-offset`\n    if (this.parentElement) {\n      this.marshal.trackValue(this.parentElement, 'layout-gap').pipe(takeUntil(this.destroySubject)).subscribe(this.triggerUpdate.bind(this));\n    }\n  }\n  // *********************************************\n  // Protected methods\n  // *********************************************\n  /**\n   * Using the current fxFlexOffset value, update the inline CSS\n   * NOTE: this will assign `margin-left` if the parent flex-direction == 'row',\n   *       otherwise `margin-top` is used for the offset.\n   * @protected\n   * @param {?=} value\n   * @return {?}\n   */\n  updateWithValue(value = '') {\n    // The flex-direction of this element's flex container. Defaults to 'row'.\n    /** @type {?} */\n    const layout = this.getFlexFlowDirection( /** @type {?} */this.parentElement, true);\n    /** @type {?} */\n    const isRtl = this.directionality.value === 'rtl';\n    if (layout === 'row' && isRtl) {\n      this.styleCache = flexOffsetCacheRowRtl;\n    } else if (layout === 'row' && !isRtl) {\n      this.styleCache = flexOffsetCacheRowLtr;\n    } else if (layout === 'column' && isRtl) {\n      this.styleCache = flexOffsetCacheColumnRtl;\n    } else if (layout === 'column' && !isRtl) {\n      this.styleCache = flexOffsetCacheColumnLtr;\n    }\n    this.addStyles(value + '', {\n      layout,\n      isRtl\n    });\n  }\n}\n\n/** @nocollapse */\n\nclass DefaultFlexOffsetDirective extends FlexOffsetDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$4;\n  }\n}\n/** @type {?} */\nconst flexOffsetCacheRowRtl = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexOffsetCacheColumnRtl = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexOffsetCacheRowLtr = /*#__PURE__*/new Map();\n/** @type {?} */\nconst flexOffsetCacheColumnLtr = /*#__PURE__*/new Map();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/flex-align/flex-align.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet FlexAlignStyleBuilder = /*#__PURE__*/(() => {\n  class FlexAlignStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    buildStyles(input) {\n      input = input || 'stretch';\n      /** @type {?} */\n      const styles = {};\n      // Cross-axis\n      switch (input) {\n        case 'start':\n          styles['align-self'] = 'flex-start';\n          break;\n        case 'end':\n          styles['align-self'] = 'flex-end';\n          break;\n        default:\n          styles['align-self'] = input;\n          break;\n      }\n      return styles;\n    }\n  }\n  /** @nocollapse */FlexAlignStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function FlexAlignStyleBuilder_Factory() {\n      return new FlexAlignStyleBuilder();\n    },\n    token: FlexAlignStyleBuilder,\n    providedIn: \"root\"\n  });\n  return FlexAlignStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$5 = ['fxFlexAlign', 'fxFlexAlign.xs', 'fxFlexAlign.sm', 'fxFlexAlign.md', 'fxFlexAlign.lg', 'fxFlexAlign.xl', 'fxFlexAlign.lt-sm', 'fxFlexAlign.lt-md', 'fxFlexAlign.lt-lg', 'fxFlexAlign.lt-xl', 'fxFlexAlign.gt-xs', 'fxFlexAlign.gt-sm', 'fxFlexAlign.gt-md', 'fxFlexAlign.gt-lg'];\n/** @type {?} */\nconst selector$5 = `\n  [fxFlexAlign], [fxFlexAlign.xs], [fxFlexAlign.sm], [fxFlexAlign.md],\n  [fxFlexAlign.lg], [fxFlexAlign.xl], [fxFlexAlign.lt-sm], [fxFlexAlign.lt-md],\n  [fxFlexAlign.lt-lg], [fxFlexAlign.lt-xl], [fxFlexAlign.gt-xs], [fxFlexAlign.gt-sm],\n  [fxFlexAlign.gt-md], [fxFlexAlign.gt-lg]\n`;\n/**\n * 'flex-align' flexbox styling directive\n * Allows element-specific overrides for cross-axis alignments in a layout container\n * @see https://css-tricks.com/almanac/properties/a/align-self/\n */\nclass FlexAlignDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.DIRECTIVE_KEY = 'flex-align';\n    this.styleCache = flexAlignCache;\n    this.init();\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst flexAlignCache = /*#__PURE__*/new Map();\nclass DefaultFlexAlignDirective extends FlexAlignDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$5;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/flex-fill/flex-fill.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst FLEX_FILL_CSS = {\n  'margin': 0,\n  'width': '100%',\n  'height': '100%',\n  'min-width': '100%',\n  'min-height': '100%'\n};\nlet FlexFillStyleBuilder = /*#__PURE__*/(() => {\n  class FlexFillStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} _input\n     * @return {?}\n     */\n    buildStyles(_input) {\n      return FLEX_FILL_CSS;\n    }\n  }\n  /** @nocollapse */FlexFillStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function FlexFillStyleBuilder_Factory() {\n      return new FlexFillStyleBuilder();\n    },\n    token: FlexFillStyleBuilder,\n    providedIn: \"root\"\n  });\n  return FlexFillStyleBuilder;\n})();\n/**\n * 'fxFill' flexbox styling directive\n *  Maximizes width and height of element in a layout container\n *\n *  NOTE: fxFill is NOT responsive API!!\n */\nclass FlexFillDirective extends BaseDirective2 {\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.styleCache = flexFillCache;\n    this.addStyles('');\n  }\n}\n\n/** @nocollapse */\n\n/** @type {?} */\nconst flexFillCache = /*#__PURE__*/new Map();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/layout-align/layout-align.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet LayoutAlignStyleBuilder = /*#__PURE__*/(() => {\n  class LayoutAlignStyleBuilder extends StyleBuilder {\n    /**\n     * @param {?} align\n     * @param {?} parent\n     * @return {?}\n     */\n    buildStyles(align, parent) {\n      /** @type {?} */\n      const css = {};\n      const [mainAxis, crossAxis] = align.split(' ');\n      // Main axis\n      switch (mainAxis) {\n        case 'center':\n          css['justify-content'] = 'center';\n          break;\n        case 'space-around':\n          css['justify-content'] = 'space-around';\n          break;\n        case 'space-between':\n          css['justify-content'] = 'space-between';\n          break;\n        case 'space-evenly':\n          css['justify-content'] = 'space-evenly';\n          break;\n        case 'end':\n        case 'flex-end':\n          css['justify-content'] = 'flex-end';\n          break;\n        case 'start':\n        case 'flex-start':\n        default:\n          css['justify-content'] = 'flex-start'; // default main axis\n          break;\n      }\n      // Cross-axis\n      switch (crossAxis) {\n        case 'start':\n        case 'flex-start':\n          css['align-items'] = css['align-content'] = 'flex-start';\n          break;\n        case 'center':\n          css['align-items'] = css['align-content'] = 'center';\n          break;\n        case 'end':\n        case 'flex-end':\n          css['align-items'] = css['align-content'] = 'flex-end';\n          break;\n        case 'space-between':\n          css['align-content'] = 'space-between';\n          css['align-items'] = 'stretch';\n          break;\n        case 'space-around':\n          css['align-content'] = 'space-around';\n          css['align-items'] = 'stretch';\n          break;\n        case 'baseline':\n          css['align-content'] = 'stretch';\n          css['align-items'] = 'baseline';\n          break;\n        case 'stretch':\n        default:\n          // 'stretch'\n          css['align-items'] = css['align-content'] = 'stretch'; // default cross axis\n          break;\n      }\n      return (/** @type {?} */extendObject(css, {\n          'display': parent.inline ? 'inline-flex' : 'flex',\n          'flex-direction': parent.layout,\n          'box-sizing': 'border-box',\n          'max-width': crossAxis === 'stretch' ? !isFlowHorizontal(parent.layout) ? '100%' : null : null,\n          'max-height': crossAxis === 'stretch' ? isFlowHorizontal(parent.layout) ? '100%' : null : null\n        })\n      );\n    }\n  }\n  /** @nocollapse */LayoutAlignStyleBuilder.ɵprov = ɵɵdefineInjectable({\n    factory: function LayoutAlignStyleBuilder_Factory() {\n      return new LayoutAlignStyleBuilder();\n    },\n    token: LayoutAlignStyleBuilder,\n    providedIn: \"root\"\n  });\n  return LayoutAlignStyleBuilder;\n})();\n/** @type {?} */\nconst inputs$6 = ['fxLayoutAlign', 'fxLayoutAlign.xs', 'fxLayoutAlign.sm', 'fxLayoutAlign.md', 'fxLayoutAlign.lg', 'fxLayoutAlign.xl', 'fxLayoutAlign.lt-sm', 'fxLayoutAlign.lt-md', 'fxLayoutAlign.lt-lg', 'fxLayoutAlign.lt-xl', 'fxLayoutAlign.gt-xs', 'fxLayoutAlign.gt-sm', 'fxLayoutAlign.gt-md', 'fxLayoutAlign.gt-lg'];\n/** @type {?} */\nconst selector$6 = `\n  [fxLayoutAlign], [fxLayoutAlign.xs], [fxLayoutAlign.sm], [fxLayoutAlign.md],\n  [fxLayoutAlign.lg], [fxLayoutAlign.xl], [fxLayoutAlign.lt-sm], [fxLayoutAlign.lt-md],\n  [fxLayoutAlign.lt-lg], [fxLayoutAlign.lt-xl], [fxLayoutAlign.gt-xs], [fxLayoutAlign.gt-sm],\n  [fxLayoutAlign.gt-md], [fxLayoutAlign.gt-lg]\n`;\n/**\n * 'layout-align' flexbox styling directive\n *  Defines positioning of child elements along main and cross axis in a layout container\n *  Optional values: {main-axis} values or {main-axis cross-axis} value pairs\n *\n * @see https://css-tricks.com/almanac/properties/j/justify-content/\n * @see https://css-tricks.com/almanac/properties/a/align-items/\n * @see https://css-tricks.com/almanac/properties/a/align-content/\n */\nclass LayoutAlignDirective extends BaseDirective2 {\n  // default inline value\n  /**\n   * @param {?} elRef\n   * @param {?} styleUtils\n   * @param {?} styleBuilder\n   * @param {?} marshal\n   */\n  constructor(elRef, styleUtils, styleBuilder, marshal) {\n    super(elRef, styleBuilder, styleUtils, marshal);\n    this.DIRECTIVE_KEY = 'layout-align';\n    this.layout = 'row'; // default flex-direction\n    // default flex-direction\n    this.inline = false; // default inline value\n    this.init();\n    this.marshal.trackValue(this.nativeElement, 'layout').pipe(takeUntil(this.destroySubject)).subscribe(this.onLayoutChange.bind(this));\n  }\n  // *********************************************\n  // Protected methods\n  // *********************************************\n  /**\n   *\n   * @protected\n   * @param {?} value\n   * @return {?}\n   */\n  updateWithValue(value) {\n    /** @type {?} */\n    const layout = this.layout || 'row';\n    /** @type {?} */\n    const inline = this.inline;\n    if (layout === 'row' && inline) {\n      this.styleCache = layoutAlignHorizontalInlineCache;\n    } else if (layout === 'row' && !inline) {\n      this.styleCache = layoutAlignHorizontalCache;\n    } else if (layout === 'row-reverse' && inline) {\n      this.styleCache = layoutAlignHorizontalRevInlineCache;\n    } else if (layout === 'row-reverse' && !inline) {\n      this.styleCache = layoutAlignHorizontalRevCache;\n    } else if (layout === 'column' && inline) {\n      this.styleCache = layoutAlignVerticalInlineCache;\n    } else if (layout === 'column' && !inline) {\n      this.styleCache = layoutAlignVerticalCache;\n    } else if (layout === 'column-reverse' && inline) {\n      this.styleCache = layoutAlignVerticalRevInlineCache;\n    } else if (layout === 'column-reverse' && !inline) {\n      this.styleCache = layoutAlignVerticalRevCache;\n    }\n    this.addStyles(value, {\n      layout,\n      inline\n    });\n  }\n  /**\n   * Cache the parent container 'flex-direction' and update the 'flex' styles\n   * @protected\n   * @param {?} matcher\n   * @return {?}\n   */\n  onLayoutChange(matcher) {\n    /** @type {?} */\n    const layoutKeys = matcher.value.split(' ');\n    this.layout = layoutKeys[0];\n    this.inline = matcher.value.includes('inline');\n    if (!LAYOUT_VALUES.find(\n    /**\n    * @param {?} x\n    * @return {?}\n    */\n    x => x === this.layout)) {\n      this.layout = 'row';\n    }\n    this.triggerUpdate();\n  }\n}\n\n/** @nocollapse */\n\nclass DefaultLayoutAlignDirective extends LayoutAlignDirective {\n  constructor() {\n    super(...arguments);\n    this.inputs = inputs$6;\n  }\n}\n/** @type {?} */\nconst layoutAlignHorizontalCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignVerticalCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignHorizontalRevCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignVerticalRevCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignHorizontalInlineCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignVerticalInlineCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignHorizontalRevInlineCache = /*#__PURE__*/new Map();\n/** @type {?} */\nconst layoutAlignVerticalRevInlineCache = /*#__PURE__*/new Map();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALL_DIRECTIVES = [DefaultLayoutDirective, DefaultLayoutGapDirective, DefaultLayoutAlignDirective, DefaultFlexOrderDirective, DefaultFlexOffsetDirective, FlexFillDirective, DefaultFlexAlignDirective, DefaultFlexDirective];\n/**\n * *****************************************************************\n * Define module for the Flex API\n * *****************************************************************\n */\nclass FlexModule {}\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * Generated from: flex/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { FlexModule, FlexStyleBuilder, FlexDirective, DefaultFlexDirective, FlexAlignStyleBuilder, FlexAlignDirective, DefaultFlexAlignDirective, FlexFillStyleBuilder, FlexFillDirective, FlexOffsetStyleBuilder, FlexOffsetDirective, DefaultFlexOffsetDirective, FlexOrderStyleBuilder, FlexOrderDirective, DefaultFlexOrderDirective, LayoutStyleBuilder, LayoutDirective, DefaultLayoutDirective, LayoutAlignStyleBuilder, LayoutAlignDirective, DefaultLayoutAlignDirective, LayoutGapStyleBuilder, LayoutGapDirective, DefaultLayoutGapDirective };\n//# sourceMappingURL=flex.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}